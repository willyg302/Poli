)]}'
{"version":3,"file":"\\packages\\liverange.js","sources":["liverange/liverange.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,wC;;AAEA,0E;AACA,qD;;AAEA,oE;AACA,oE;;AAEA,oC;AACA,oE;AACA,kD;AACA,6C;AACA,gB;AACA,O;AACA,wB;AACA,yB;AACA,4B;AACA,iB;;AAEA,mE;AACA,6D;AACA,sE;AACA,+B;AACA,oD;AACA,4B;AACA,iB;;AAEA,c;AACA,K;;AAEA,2C;AACA,wB;AACA,wB;AACA,U;AACA,kD;AACA,mD;AACA,gC;AACA,+C;AACA,qD;AACA,wD;AACA,0B;AACA,K;AACA,6C;AACA,qD;AACA,gE;AACA,wB;AACA,K;AACA,wB;AACA,G;AACA,E;;;AAGA,wD;AACA,E;AACA,kE;AACA,kE;AACA,gE;AACA,gE;AACA,iE;AACA,mE;AACA,oE;AACA,kE;AACA,oE;AACA,8D;AACA,4C;AACA,E;AACA,mE;AACA,8D;AACA,+D;AACA,+C;AACA,E;AACA,uD;AACA,iE;AACA,mE;AACA,+D;AACA,Y;AACA,E;AACA,gE;AACA,iE;AACA,kE;AACA,iD;AACA,E;AACA,gE;AACA,gE;AACA,iE;AACA,oE;AACA,+D;AACA,2D;AACA,E;AACA,+D;AACA,gC;AACA,+C;AACA,qD;AACA,0B;AACA,6B;AACA,U;AACA,2B;AACA,oE;AACA,G;AACA,qB;;AAEA,0D;;AAEA,4C;AACA,wC;AACA,sC;;AAEA,+D;AACA,iC;AACA,I;AACA,iE;AACA,gE;AACA,qE;AACA,iE;AACA,kE;AACA,gE;AACA,yB;AACA,I;AACA,wE;AACA,wD;AACA,I;AACA,wE;AACA,iE;;AAEA,wE;AACA,qE;;AAEA,mE;AACA,8D;AACA,iE;AACA,mE;AACA,iE;AACA,qD;AACA,yD;AACA,I;AACA,qE;AACA,6D;AACA,qE;AACA,kD;;AAEA,iE;AACA,oD;AACA,gD;AACA,E;;AAEA,8E;AACA,Y;AACA,6D;AACA,8D;AACA,kE;AACA,iE;AACA,8D;AACA,kE;AACA,mE;AACA,I;AACA,qE;AACA,sE;AACA,gE;AACA,sE;AACA,oE;AACA,qE;AACA,sE;AACA,wC;AACA,I;AACA,mE;AACA,oE;AACA,oE;AACA,kB;AACA,I;AACA,qD;AACA,2E;AACA,sD;AACA,mD;AACA,sB;AACA,6D;AACA,yC;AACA,4B;AACA,K;AACA,2B;AACA,gB;AACA,2B;AACA,4B;AACA,gB;AACA,Y;AACA,K;AACA,G;AACA,e;AACA,E;;AAEA,kD;AACA,0B;AACA,8B;AACA,c;AACA,E;;AAEA,qC;AACA,4D;AACA,oE;AACA,2C;AACA,gB;AACA,qB;AACA,O;AACA,mB;AACA,qB;AACA,kB;AACA,yB;AACA,gB;AACA,K;;AAEA,oD;AACA,uB;AACA,8D;AACA,0B;AACA,uB;AACA,Q;AACA,gC;AACA,G;AACA,E;;AAEA,oE;AACA,kE;AACA,gB;AACA,E;AACA,qE;AACA,oE;AACA,kE;AACA,kE;AACA,mB;AACA,E;AACA,mE;AACA,oD;AACA,kB;;AAEA,kB;AACA,wD;AACA,+C;;AAEA,yC;AACA,oB;AACA,4B;AACA,0B;AACA,O;AACA,gC;AACA,sB;AACA,wD;AACA,4D;AACA,kD;AACA,S;AACA,O;AACA,O;;AAEA,0D;AACA,6D;;AAEA,oC;AACA,yE;AACA,0C;AACA,0B;AACA,8B;AACA,gD;AACA,O;;AAEA,0D;AACA,gC;AACA,4C;AACA,8B;AACA,0C;AACA,K;;AAEA,mC;;AAEA,U;AACA,gF;AACA,0E;AACA,mC;AACA,G;AACA,E;;AAEA,6D;AACA,6C;AACA,qB;AACA,E;;AAEA,6D;AACA,4C;AACA,mB;AACA,E;;AAEA,qE;AACA,4C;AACA,gD;AACA,gC;AACA,E;;AAEA,gE;AACA,iE;AACA,mC;AACA,E;AACA,uD;AACA,kE;AACA,kE;AACA,2D;AACA,0B;AACA,E;AACA,+D;AACA,gE;AACA,8D;AACA,oC;AACA,E;AACA,kE;AACA,mC;AACA,6D;AACA,2C;AACA,yC;;AAEA,qB;;AAEA,sD;AACA,yC;AACA,gC;AACA,6D;AACA,0C;AACA,uD;AACA,mD;AACA,0C;AACA,0D;AACA,kC;AACA,sC;AACA,kC;AACA,8C;AACA,sD;AACA,iC;AACA,qB;AACA,O;AACA,Y;AACA,oB;AACA,yD;AACA,6C;AACA,4B;AACA,O;AACA,qB;AACA,K;AACA,I;;AAEA,wD;AACA,E;;AAEA,wC;AACA,oC;AACA,gC;AACA,C;AACA,yC;AACA,a;AACA,0C;AACA,uC;AACA,+C;AACA,2C;AACA,2C;AACA,oC;AACA,G;;AAEA,4C;AACA,yB;AACA,yC;AACA,G;;AAEA,iB;AACA,E;;AAEA,oC;AACA,wC;AACA,C;AACA,oE;AACA,yC;AACA,kE;AACA,yC;AACA,mB;AACA,6B;AACA,+B;AACA,Y;AACA,+B;AACA,iC;AACA,K;AACA,G;AACA,E;;AAEA,uD;AACA,uD;AACA,oB;AACA,E;AACA,mD;AACA,kE;AACA,mC;AACA,mE;AACA,kB;AACA,E;AACA,yC;AACA,0D;AACA,2B;AACA,mE;;AAEA,kD;AACA,0B;AACA,wD;;AAEA,kC;AACA,0E;AACA,kE;AACA,wB;AACA,kB;AACA,kC;AACA,gC;AACA,0B;AACA,c;AACA,kB;AACA,gB;AACA,8E;AACA,K;;AAEA,mB;AACA,K;AACA,E;;;AAGA,uE;AACA,E;AACA,uE;AACA,+E;AACA,2E;AACA,8E;AACA,4E;AACA,2E;AACA,0B;AACA,E;AACA,0C;AACA,E;AACA,mE;AACA,0E;AACA,0B;AACA,+C;AACA,yC;AACA,6B;AACA,yB;;AAEA,kC;AACA,mB;AACA,kE;AACA,iB;AACA,uD;;AAEA,0C;AACA,4C;AACA,qC;;AAEA,iB;;AAEA,2C;AACA,+B;;AAEA,0B;;AAEA,gB;AACA,uE;AACA,c;AACA,wE;;AAEA,6C;AACA,gE;AACA,G;;AAEA,gC;AACA,qD;AACA,8C;AACA,4C;;AAEA,kC;;AAEA,mD;AACA,wE;;AAEA,a;AACA,E;;AAEA,oE;AACA,sE;AACA,2E;AACA,kC;AACA,E;AACA,wE;AACA,uE;AACA,oE;AACA,iE;;AAEA,wB;AACA,W;;AAEA,sB;AACA,oC;AACA,yB;;AAEA,kC;AACA,gC;;AAEA,iC;AACA,kC;AACA,kC;AACA,gC;AACA,8B;AACA,E;;AAEA,6E;AACA,yE;AACA,+E;AACA,+E;AACA,4E;AACA,0D;AACA,E;AACA,wE;AACA,gC;AACA,kE;AACA,gC;AACA,0B;AACA,gC;;AAEA,0B;AACA,mB;AACA,yE;AACA,0B;AACA,iB;AACA,8D;AACA,E;;AAEA,4D;AACA,sD;AACA,oB;AACA,mD;AACA,kC;;AAEA,gC;AACA,W;;AAEA,oB;AACA,yD;;AAEA,6D;AACA,4C;AACA,6B;AACA,sC;AACA,6D;AACA,+D;AACA,E;;AAEA,2D;AACA,sD;AACA,oB;AACA,kD;AACA,+B;;AAEA,8B;AACA,W;;AAEA,oB;AACA,iE;;AAEA,uD;AACA,oC;AACA,2B;AACA,8D;AACA,wD;AACA,iE;AACA,E;;AAEA,wD;AACA,sD;AACA,uD;AACA,a;AACA,E;AACA,qD;AACA,wD;AACA,4D;AACA,wD;AACA,0C;AACA,6B;AACA,0E;AACA,6E;AACA,yB;AACA,gB;AACA,G;;AAEA,2C;AACA,oC;AACA,sC;;AAEA,6B;AACA,mE;AACA,iC;AACA,2B;AACA,oC;AACA,+D;AACA,iE;AACA,G;;AAEA,2D;AACA,+D;AACA,uC;AACA,4B;AACA,8D;AACA,0D;AACA,mE;AACA,G;;AAEA,iD;;AAEA,Y;AACA,0D;AACA,wB;AACA,0B;;AAEA,gB;AACA,E;;AAEA,gE;AACA,8C;AACA,E;AACA,gE;AACA,gE;AACA,iE;AACA,iB;AACA,8D;AACA,yE;AACA,a;AACA,kB;;AAEA,wB;AACA,gB;;AAEA,6D;AACA,E;;AAEA,8D;AACA,2C;AACA,+C;AACA,a;AACA,kB;;AAEA,wB;AACA,gB;;AAEA,mD;AACA,E;;AAEA,yD;AACA,sD;AACA,oD;AACA,sD;AACA,yD;AACA,0D;;AAEA,sC;AACA,kB;;AAEA,sD;AACA,gE;AACA,qC;AACA,G;;AAEA,6B;AACA,gB;AACA,qB;AACA,8C;AACA,wC;AACA,wC;AACA,2B;AACA,oB;AACA,iC;AACA,K;AACA,oD;AACA,oC;AACA,4B;AACA,G;;AAEA,c;AACA,E","sourcesContent":["// Stand back, I'm going to try SCIENCE.\r\n\r\n// Possible optimization: get rid of _startIndex/_endIndex and just search\r\n// the list. Not clear which strategy will be faster.\r\n\r\n// Possible extension: could allow zero-length ranges is some cases,\r\n// by encoding both 'enter' and 'leave' type events in the same list\r\n\r\nvar canSetTextProps = (function () {\r\n  // IE8 and earlier don't support expando attributes on text nodes,\r\n  // but fortunately they are allowed on comments.\r\n  var testElem = document.createTextNode(\"\");\r\n  var exception;\r\n  try {\r\n    testElem.test = 123;\r\n  } catch (exception) { }\r\n  if (testElem.test !== 123)\r\n    return false;\r\n\r\n  // IE9 and 10 have a weird issue with multiple text nodes next to\r\n  // each other losing their expando attributes. Use the same\r\n  // workaround as IE8. Not sure how to test this as a feature, so use\r\n  // browser detection instead.\r\n  // See https://github.com/meteor/meteor/issues/458\r\n  if (document.documentMode)\r\n    return false;\r\n\r\n  return true;\r\n})();\r\n\r\nvar wrapEndpoints = function (start, end) {\r\n  if (canSetTextProps) {\r\n    return [start, end];\r\n  } else {\r\n    // IE8 workaround: insert some empty comments.\r\n    // Comments whose text is \"IE\" are stripped out\r\n    // in cross-browser testing.\r\n    if (start.nodeType === 3 /* text node */) {\r\n      var placeholder = document.createComment(\"IE\");\r\n      start.parentNode.insertBefore(placeholder, start);\r\n      start = placeholder;\r\n    }\r\n    if (end.nodeType === 3 /* text node */) {\r\n      var placeholder = document.createComment(\"IE\");\r\n      end.parentNode.insertBefore(placeholder, end.nextSibling);\r\n      end = placeholder;\r\n    }\r\n    return [start, end];\r\n  }\r\n};\r\n\r\n\r\n// This is a constructor (invoke it as 'new LiveRange').\r\n//\r\n// Create a range, tagged 'tag', that includes start, end, and all\r\n// the nodes between them, and the children of all of those nodes,\r\n// but includes no other nodes. If there are other ranges tagged\r\n// 'tag' that contain this exact set of nodes, then: if inner is\r\n// false (the default), the new range will be outside all of them\r\n// (will contain all of them), or if inner is true, then it will be\r\n// inside all of them (be contained by all of them.) If there are no\r\n// other ranges tagged 'tag' that contain this exact set of nodes,\r\n// then 'inner' is ignored because the nesting of the new range with\r\n// respect to other ranges is uniquely determined. (Nesting of\r\n// ranges with different tags is undefined.)\r\n//\r\n// To track the range as it's relocated, some of the DOM nodes that\r\n// are part of the range will have an expando attribute set on\r\n// them. The name of the expando attribute will be the value of\r\n// 'tag', so pick something that won't collide.\r\n//\r\n// Instead of start and end, you can pass a document or\r\n// documentfragment for start and leave end undefined. Or you can\r\n// pass a node for start and leave end undefined, in which case end\r\n// === start. If start and end are distinct nodes, they must be\r\n// siblings.\r\n//\r\n// You can set any attributes you like on the returned LiveRange\r\n// object, with two exceptions. First, attribute names that start\r\n// with '_' are reserved. Second, the attribute 'tag' contains the\r\n// tag name of this range and mustn't be changed.\r\n//\r\n// It would be possible to add a fast path through this function\r\n// when caller can promise that there is no range that starts on\r\n// start that does not end by end, and vice versa. eg: when start\r\n// and end are the first and last child of their parent respectively\r\n// or when caller is building up the range tree from the inside\r\n// out. Let's wait for the profiler to tell us to add this.\r\n//\r\n// XXX Should eventually support LiveRanges where start === end\r\n// and start.parentNode is null.\r\nLiveRange = function (tag, start, end, inner) {\r\n  if (start.nodeType === 11 /* DocumentFragment */) {\r\n    end = start.lastChild;\r\n    start = start.firstChild;\r\n  } else {\r\n    if (! start.parentNode)\r\n      throw new Error(\"LiveRange start and end must have a parent\");\r\n  }\r\n  end = end || start;\r\n\r\n  this.tag = tag; // must be set before calling _ensureTag\r\n\r\n  var endpoints = wrapEndpoints(start, end);\r\n  start = this._ensureTag(endpoints[0]);\r\n  end = this._ensureTag(endpoints[1]);\r\n\r\n  // Decide at what indices in start[tag][0] and end[tag][1] we\r\n  // should insert the new range.\r\n  //\r\n  // The start[tag][0] array lists the other ranges that start at\r\n  // `start`, and we must choose an insertion index that puts us\r\n  // inside the ones that end at later siblings, and outside the ones\r\n  // that end at earlier siblings.  The ones that end at the same\r\n  // sibling (i.e. share both our start and end) we must be inside\r\n  // or outside of depending on `inner`.  The array lists ranges\r\n  // from the outside in.\r\n  //\r\n  // The same logic applies to end[tag][1], which lists the other ranges\r\n  // that happen to end at `end` from in the inside out.\r\n  //\r\n  // Liveranges technically start just before, and end just after, their\r\n  // start and end nodes to which the liverange data is attached.\r\n\r\n  var startIndex = findPosition(start[tag][0], true, end, start, inner);\r\n  var endIndex = findPosition(end[tag][1], false, start, end, inner);\r\n\r\n  // this._start is the node N such that we begin before N, but not\r\n  // before the node before N in the preorder traversal of the\r\n  // document (if there is such a node.) this._start[this.tag][0]\r\n  // will be the list of all LiveRanges for which this._start is N,\r\n  // including us, sorted in the order that the ranges start. and\r\n  // finally, this._startIndex is the value such that\r\n  // this._start[this.tag][0][this._startIndex] === this.\r\n  //\r\n  // Similarly for this._end, except it's the node N such that we end\r\n  // after N, but not after the node after N in the postorder\r\n  // traversal; and the data is stored in this._end[this.tag][1], and\r\n  // it's sorted in the order that the ranges end.\r\n\r\n  // Set this._start, this._end, this._startIndex, this._endIndex\r\n  this._insertEntries(start, 0, startIndex, [this]);\r\n  this._insertEntries(end, 1, endIndex, [this]);\r\n};\r\n\r\nvar findPosition = function(ranges, findEndNotStart, edge, otherEdge, inner) {\r\n  var index;\r\n  // For purpose of finding where we belong in start[tag][0],\r\n  // walk the array and determine where we start to see ranges\r\n  // end at `end` (==edge) or earlier.  For the purpose of finding\r\n  // where we belong in end[tag][1], walk the array and determine\r\n  // where we start to see ranges start at `start` (==edge) or\r\n  // earlier.  In both cases, we slide a sibling pointer backwards\r\n  // looking for `edge`, though the details are slightly different.\r\n  //\r\n  // Use `inner` to take first or last candidate index for insertion.\r\n  // Candidate indices are:  Right before a range whose edge is `edge`\r\n  // (i.e., a range with same start and end as we are creating),\r\n  // or the index where ranges start to have edges earlier than `edge`\r\n  // (treating the end of the list as such an index).  We detect the\r\n  // latter case when `n` hits `edge` without hitting the edge of the\r\n  // current range; that is, it is about to move past `edge`.  This is\r\n  // always an appropriate time to stop.\r\n  //\r\n  // Joint traversal of the array and DOM should be fast.  The most\r\n  // expensive thing to happen would be a single walk from lastChild\r\n  // to end looking for range ends, or from end to start looking for\r\n  // range starts.\r\n  //\r\n  // invariant: n >= edge (\"n is after, or is, edge\")\r\n  var initialN = (findEndNotStart ? edge.parentNode.lastChild : otherEdge);\r\n  var takeFirst = (findEndNotStart ? ! inner : inner);\r\n  for(var i=0, n=initialN; i<=ranges.length; i++) {\r\n    var r = ranges[i];\r\n    var curEdge = r && (findEndNotStart ? r._end : r._start);\r\n    while (n !== curEdge && n !== edge) {\r\n      n = n.previousSibling;\r\n    }\r\n    if (curEdge === edge) {\r\n      index = i;\r\n      if (takeFirst) break;\r\n    } else if (n === edge) {\r\n      index = i;\r\n      break;\r\n    }\r\n  }\r\n  return index;\r\n};\r\n\r\nLiveRange.prototype._ensureTag = function (node) {\r\n  if (!(this.tag in node))\r\n    node[this.tag] = [[], []];\r\n  return node;\r\n};\r\n\r\nvar canDeleteExpandos = (function() {\r\n  // IE7 can't remove expando attributes from DOM nodes with\r\n  // delete. Instead you must remove them with node.removeAttribute.\r\n  var node = document.createElement(\"DIV\");\r\n  var exception;\r\n  var result = false;\r\n  try {\r\n    node.test = 12;\r\n    delete node.test;\r\n    result = true;\r\n  } catch (exception) { }\r\n  return result;\r\n})();\r\n\r\nLiveRange._cleanNode = function (tag, node, force) {\r\n  var data = node[tag];\r\n  if (data && (!(data[0].length + data[1].length) || force)) {\r\n    if (canDeleteExpandos)\r\n      delete node[tag];\r\n    else\r\n      node.removeAttribute(tag);\r\n  }\r\n};\r\n\r\n// Delete a LiveRange. This is analogous to removing a DOM node from\r\n// its parent -- it will no longer appear when traversing the tree\r\n// with visit().\r\n//\r\n// On modern browsers there is no requirement to delete LiveRanges on\r\n// defunct nodes. They will be garbage collected just like any other\r\n// object. However, on old versions of IE, you probably do need to\r\n// manually remove all ranges because IE can't GC reference cycles\r\n// through the DOM.\r\n//\r\n// Pass true for `recursive` to also destroy all descendent ranges.\r\nLiveRange.prototype.destroy = function (recursive) {\r\n  var self = this;\r\n\r\n  if (recursive) {\r\n    // recursive case: destroy all descendent ranges too\r\n    // (more efficient than actually recursing)\r\n\r\n    this.visit(function(isStart, range) {\r\n      if (isStart) {\r\n        range._start = null;\r\n        range._end = null;\r\n      }\r\n    }, function(isStart, node) {\r\n      if (! isStart) {\r\n        // when leaving a node, force-clean its children\r\n        for(var n = node.firstChild; n; n = n.nextSibling) {\r\n          LiveRange._cleanNode(self.tag, n, true);\r\n        }\r\n      }\r\n    });\r\n\r\n    this._removeEntries(this._start, 0, this._startIndex);\r\n    this._removeEntries(this._end, 1, 0, this._endIndex + 1);\r\n\r\n    if (this._start !== this._end) {\r\n      // force-clean the top-level nodes in this, besides _start and _end\r\n      for(var n = this._start.nextSibling;\r\n          n !== this._end;\r\n          n = n.nextSibling) {\r\n        LiveRange._cleanNode(self.tag, n, true);\r\n      }\r\n\r\n      // clean ends on this._start and starts on this._end\r\n      if (this._start[self.tag])\r\n        this._removeEntries(this._start, 1);\r\n      if (this._end[self.tag])\r\n        this._removeEntries(this._end, 0);\r\n    }\r\n\r\n    this._start = this._end = null;\r\n\r\n  } else {\r\n    this._removeEntries(this._start, 0, this._startIndex, this._startIndex + 1);\r\n    this._removeEntries(this._end, 1, this._endIndex, this._endIndex + 1);\r\n    this._start = this._end = null;\r\n  }\r\n};\r\n\r\n// Return the first node in the range (in preorder traversal)\r\nLiveRange.prototype.firstNode = function () {\r\n  return this._start;\r\n};\r\n\r\n// Return the last node in the range (in postorder traversal)\r\nLiveRange.prototype.lastNode = function () {\r\n  return this._end;\r\n};\r\n\r\n// Return the node that immediately contains this LiveRange, that is,\r\n// the parentNode of firstNode and lastNode.\r\nLiveRange.prototype.containerNode = function() {\r\n  return this._start.parentNode;\r\n};\r\n\r\n// Walk through the current contents of a LiveRange, enumerating\r\n// either the contained ranges (with the same tag as this range),\r\n// the contained elements, or both.\r\n//\r\n// visitRange(isStart, range) is invoked for each range\r\n// start-point or end-point that we encounter as we walk the range\r\n// stored in 'this' (not counting the endpoints of 'this' itself.)\r\n// visitNode(isStart, node) is similar but for nodes.  Both\r\n// functions are optional.\r\n//\r\n// If you return false (i.e. a value === false) from visitRange\r\n// or visitNode when isStart is true, the children of that range\r\n// or node are skipped, and the next callback will be the same\r\n// range or node with isStart false.\r\n//\r\n// If you create or destroy ranges with this tag from a visitation\r\n// function, results are undefined!\r\nLiveRange.prototype.visit = function(visitRange, visitNode) {\r\n  visitRange = visitRange || function() {};\r\n  visitNode = visitNode || function() {};\r\n\r\n  var tag = this.tag;\r\n\r\n  var recurse = function(start, end, startRangeSkip) {\r\n    var startIndex = startRangeSkip || 0;\r\n    var after = end.nextSibling;\r\n    for(var n = start; n && n !== after; n = n.nextSibling) {\r\n      var startData = n[tag] && n[tag][0];\r\n      if (startData && startIndex < startData.length) {\r\n        // immediate child range that starts with n\r\n        var range = startData[startIndex];\r\n        // be robust if visitRange mutates _start or _end;\r\n        // useful in destroy(true)\r\n        var rangeStart = range._start;\r\n        var rangeEnd = range._end;\r\n        if (visitRange(true, range) !== false)\r\n          recurse(rangeStart, rangeEnd, startIndex+1);\r\n        visitRange(false, range);\r\n        n = rangeEnd;\r\n      }\r\n      else {\r\n        // bare node\r\n        if (visitNode(true, n) !== false && n.firstChild)\r\n          recurse(n.firstChild, n.lastChild);\r\n        visitNode(false, n);\r\n      }\r\n      startIndex = 0;\r\n    }\r\n  };\r\n\r\n  recurse(this._start, this._end, this._startIndex + 1);\r\n};\r\n\r\n// startEnd === 0 for starts, 1 for ends\r\nLiveRange.prototype._removeEntries =\r\n  function(node, startEnd, i, j)\r\n{\r\n  var entries = node[this.tag][startEnd];\r\n  i = i || 0;\r\n  j = (j || j === 0) ? j : entries.length;\r\n  var removed = entries.splice(i, j-i);\r\n  // fix up remaining ranges (not removed ones)\r\n  for(var a = i; a < entries.length; a++) {\r\n    if (startEnd) entries[a]._endIndex = a;\r\n    else entries[a]._startIndex = a;\r\n  }\r\n\r\n  // potentially remove empty liverange data\r\n  if (! entries.length) {\r\n    LiveRange._cleanNode(this.tag, node);\r\n  }\r\n\r\n  return removed;\r\n};\r\n\r\nLiveRange.prototype._insertEntries =\r\n  function(node, startEnd, i, newRanges)\r\n{\r\n  // insert the new ranges and \"adopt\" them by setting node pointers\r\n  var entries = node[this.tag][startEnd];\r\n  Array.prototype.splice.apply(entries, [i, 0].concat(newRanges));\r\n  for(var a=i; a < entries.length; a++) {\r\n    if (startEnd) {\r\n      entries[a]._end = node;\r\n      entries[a]._endIndex = a;\r\n    } else {\r\n      entries[a]._start = node;\r\n      entries[a]._startIndex = a;\r\n    }\r\n  }\r\n};\r\n\r\n// Replace the contents of this range with the provided\r\n// DocumentFragment. Returns the previous contents as a\r\n// DocumentFragment.\r\n//\r\n// \"The right thing happens\" with child LiveRanges:\r\n// - If there were child LiveRanges inside us, they will end up in\r\n//   the returned DocumentFragment.\r\n// - If the input DocumentFragment has LiveRanges, they will become\r\n//   our children.\r\n//\r\n// It is illegal for newFrag to be empty.\r\nLiveRange.prototype.replaceContents = function (newFrag) {\r\n  if (! newFrag.firstChild)\r\n    throw new Error(\"replaceContents requires non-empty fragment\");\r\n\r\n  return this.operate(function(oldStart, oldEnd) {\r\n    // Insert new fragment\r\n    oldStart.parentNode.insertBefore(newFrag, oldStart);\r\n\r\n    // Pull out departing fragment\r\n    // Possible optimization: use W3C Ranges on browsers that support them\r\n    var retFrag = oldStart.ownerDocument.createDocumentFragment();\r\n    var walk = oldStart;\r\n    while (true) {\r\n      var next = walk.nextSibling;\r\n      retFrag.appendChild(walk);\r\n      if (walk === oldEnd)\r\n        break;\r\n      walk = next;\r\n      if (!walk)\r\n        throw new Error(\"LiveRanges must begin and end on siblings in order\");\r\n    }\r\n\r\n    return retFrag;\r\n  });\r\n};\r\n\r\n\r\n// Perform a user-specified DOM mutation on the contents of this range.\r\n//\r\n// `func` is called with two parameters, `oldStart` and `oldEnd`, equal\r\n// to the original firstNode() and lastNode() of this range.  `func` is allowed\r\n// to perform arbitrary operations on the sequence of nodes from `oldStart`\r\n// to `oldEnd` and on child ranges of this range.  `func` may NOT call methods\r\n// on this range itself or otherwise rely on the existence of this range and\r\n// enclosing ranges.  `func` must leave at least one node to become the new\r\n// contents of this range.\r\n//\r\n// The return value of `func` is returned.\r\n//\r\n// This method is a generalization of replaceContents that works by\r\n// temporarily removing this LiveRange from the DOM and restoring it after\r\n// `func` has been called.\r\nLiveRange.prototype.operate = function (func) {\r\n  // boundary nodes of departing fragment\r\n  var oldStart = this._start;\r\n  var oldEnd = this._end;\r\n\r\n  // pull off outer liverange data\r\n  var outerStarts =\r\n        this._removeEntries(oldStart, 0, 0, this._startIndex + 1);\r\n  var outerEnds =\r\n        this._removeEntries(oldEnd, 1, this._endIndex);\r\n\r\n  var containerNode = oldStart.parentNode;\r\n  var beforeNode = oldStart.previousSibling;\r\n  var afterNode = oldEnd.nextSibling;\r\n\r\n  var ret = null;\r\n\r\n  // perform user-specifiedDOM manipulation\r\n  ret = func(oldStart, oldEnd);\r\n\r\n  // see what we've got...\r\n\r\n  var newStart =\r\n        beforeNode ? beforeNode.nextSibling : containerNode.firstChild;\r\n  var newEnd =\r\n        afterNode ? afterNode.previousSibling : containerNode.lastChild;\r\n\r\n  if (! newStart || newStart === afterNode) {\r\n    throw new Error(\"Ranges must contain at least one element\");\r\n  }\r\n\r\n  // wrap endpoints if necessary\r\n  var newEndpoints = wrapEndpoints(newStart, newEnd);\r\n  newStart = this._ensureTag(newEndpoints[0]);\r\n  newEnd = this._ensureTag(newEndpoints[1]);\r\n\r\n  // put the outer liveranges back\r\n\r\n  this._insertEntries(newStart, 0, 0, outerStarts);\r\n  this._insertEntries(newEnd, 1, newEnd[this.tag][1].length, outerEnds);\r\n\r\n  return ret;\r\n};\r\n\r\n// Move all liverange data represented in the DOM from sourceNode to\r\n// targetNode.  targetNode must be capable of receiving liverange tags\r\n// (for example, a node that has been the first or last node of a liverange\r\n// before; not a text node in IE).\r\n//\r\n// This is a low-level operation suitable for moving liveranges en masse\r\n// from one DOM tree to another, where transplantTag is called on every\r\n// pair of nodes such that targetNode takes the place of sourceNode.\r\nLiveRange.transplantTag = function(tag, targetNode, sourceNode) {\r\n\r\n  if (! sourceNode[tag])\r\n    return;\r\n\r\n  // copy data pointer\r\n  targetNode[tag] = sourceNode[tag];\r\n  sourceNode[tag] = null;\r\n\r\n  var starts = targetNode[tag][0];\r\n  var ends = targetNode[tag][1];\r\n\r\n  // fix _start and _end pointers\r\n  for(var i=0;i<starts.length;i++)\r\n    starts[i]._start = targetNode;\r\n  for(var i=0;i<ends.length;i++)\r\n    ends[i]._end = targetNode;\r\n};\r\n\r\n// Takes two sibling nodes tgtStart and tgtEnd with no LiveRange data on them\r\n// and a LiveRange srcRange in a separate DOM tree.  Transplants srcRange\r\n// to span from tgtStart to tgtEnd, and also copies info about enclosing ranges\r\n// starting on srcRange._start or ending on srcRange._end.  tgtStart and tgtEnd\r\n// must be capable of receiving liverange tags (for example, nodes that have\r\n// held liverange data in the past; not text nodes in IE).\r\n//\r\n// This is a low-level operation suitable for moving liveranges en masse\r\n// from one DOM tree to another.\r\nLiveRange.transplantRange = function(tgtStart, tgtEnd, srcRange) {\r\n  srcRange._ensureTag(tgtStart);\r\n  if (tgtEnd !== tgtStart)\r\n    srcRange._ensureTag(tgtEnd);\r\n\r\n  srcRange._insertEntries(\r\n    tgtStart, 0, 0,\r\n    srcRange._start[srcRange.tag][0].slice(0, srcRange._startIndex + 1));\r\n  srcRange._insertEntries(\r\n    tgtEnd, 1, 0,\r\n    srcRange._end[srcRange.tag][1].slice(srcRange._endIndex));\r\n};\r\n\r\n// Inserts a DocumentFragment immediately before this range.\r\n// The new nodes are outside this range but inside all\r\n// enclosing ranges.\r\nLiveRange.prototype.insertBefore = function(frag) {\r\n  var fragStart = frag.firstChild;\r\n\r\n  if (! fragStart) // empty frag\r\n    return;\r\n\r\n  // insert into DOM\r\n  this._start.parentNode.insertBefore(frag, this._start);\r\n\r\n  // move starts of ranges that begin on this._start, but are\r\n  // outside this, to beginning of fragStart\r\n  this._ensureTag(fragStart);\r\n  this._insertEntries(fragStart, 0, 0,\r\n                       this._removeEntries(this._start, 0, 0,\r\n                                            this._startIndex));\r\n};\r\n\r\n// Inserts a DocumentFragment immediately after this range.\r\n// The new nodes are outside this range but inside all\r\n// enclosing ranges.\r\nLiveRange.prototype.insertAfter = function(frag) {\r\n  var fragEnd = frag.lastChild;\r\n\r\n  if (! fragEnd) // empty frag\r\n    return;\r\n\r\n  // insert into DOM\r\n  this._end.parentNode.insertBefore(frag, this._end.nextSibling);\r\n\r\n  // move ends of ranges that end on this._end, but are\r\n  // outside this, to end of fragEnd\r\n  this._ensureTag(fragEnd);\r\n  this._insertEntries(fragEnd, 1, fragEnd[this.tag][1].length,\r\n                       this._removeEntries(this._end, 1,\r\n                                            this._endIndex + 1));\r\n};\r\n\r\n// Extracts this range and its contents from the DOM and\r\n// puts it into a DocumentFragment, which is returned.\r\n// All nodes and ranges outside this range are properly\r\n// preserved.\r\n//\r\n// Because liveranges must contain at least one node,\r\n// it is illegal to perform `extract` if the immediately\r\n// enclosing range would become empty.  If this precondition\r\n// is violated, no action is taken and null is returned.\r\nLiveRange.prototype.extract = function() {\r\n  if (this._startIndex > 0 &&\r\n      this._start[this.tag][0][this._startIndex - 1]._end === this._end) {\r\n    // immediately enclosing range wraps same nodes, so can't extract because\r\n    // it would empty it.\r\n    return null;\r\n  }\r\n\r\n  var before = this._start.previousSibling;\r\n  var after = this._end.nextSibling;\r\n  var parent = this._start.parentNode;\r\n\r\n  if (this._startIndex > 0) {\r\n    // must be a later node where outer ranges that start here end;\r\n    // move their starts to after\r\n    this._ensureTag(after);\r\n    this._insertEntries(after, 0, 0,\r\n                         this._removeEntries(this._start, 0, 0,\r\n                                              this._startIndex));\r\n  }\r\n\r\n  if (this._endIndex < this._end[this.tag][1].length - 1) {\r\n    // must be an earlier node where outer ranges that end here\r\n    // start; move their ends to before\r\n    this._ensureTag(before);\r\n    this._insertEntries(before, 1, before[this.tag][1].length,\r\n                         this._removeEntries(this._end, 1,\r\n                                              this._endIndex + 1));\r\n  }\r\n\r\n  var result = document.createDocumentFragment();\r\n\r\n  for(var n;\r\n      n = before ? before.nextSibling : parent.firstChild,\r\n      n && n !== after;)\r\n    result.appendChild(n);\r\n\r\n  return result;\r\n};\r\n\r\n// Find the immediately enclosing parent range of this range, or\r\n// null if this range has no enclosing ranges.\r\n//\r\n// If `withSameContainer` is true, we stop looking when we reach\r\n// this range's container node (the parent of its endpoints) and\r\n// only return liveranges whose first and last nodes are siblings\r\n// of this one's.\r\nLiveRange.prototype.findParent = function(withSameContainer) {\r\n  var result = enclosingRangeSearch(this.tag, this._end, this._endIndex);\r\n  if (result)\r\n    return result;\r\n\r\n  if (withSameContainer)\r\n    return null;\r\n\r\n  return LiveRange.findRange(this.tag, this.containerNode());\r\n};\r\n\r\n// Find the nearest enclosing range containing `node`, if any.\r\nLiveRange.findRange = function(tag, node) {\r\n  var result = enclosingRangeSearch(tag, node);\r\n  if (result)\r\n    return result;\r\n\r\n  if (! node.parentNode)\r\n    return null;\r\n\r\n  return LiveRange.findRange(tag, node.parentNode);\r\n};\r\n\r\nvar enclosingRangeSearch = function(tag, end, endIndex) {\r\n  // Search for an enclosing range, at the same level,\r\n  // starting at node `end` or after the range whose\r\n  // position in the end array of `end` is `endIndex`.\r\n  // The search works by scanning forwards for range ends\r\n  // while skipping over ranges whose starts we encounter.\r\n\r\n  if (typeof endIndex === \"undefined\")\r\n    endIndex = -1;\r\n\r\n  if (end[tag] && endIndex + 1 < end[tag][1].length) {\r\n    // immediately enclosing range ends at same node as this one\r\n    return end[tag][1][endIndex + 1];\r\n  }\r\n\r\n  var node = end.nextSibling;\r\n  while (node) {\r\n    var endIndex = 0;\r\n    var startData = node[tag] && node[tag][0];\r\n    if (startData && startData.length) {\r\n      // skip over sibling of this range\r\n      var r = startData[0];\r\n      node = r._end;\r\n      endIndex = r._endIndex + 1;\r\n    }\r\n    if (node[tag] && endIndex < node[tag][1].length)\r\n      return node[tag][1][endIndex];\r\n    node = node.nextSibling;\r\n  }\r\n\r\n  return null;\r\n};\r\n"]}