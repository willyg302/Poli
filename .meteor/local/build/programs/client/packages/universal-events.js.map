)]}'
{"version":3,"file":"\\packages\\universal-events.js","sources":["universal-events/listener.js","universal-events/events-w3c.js","universal-events/events-ie.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,6E;AACA,E;AACA,+D;AACA,mE;AACA,mE;AACA,iE;AACA,sE;AACA,kE;AACA,0D;AACA,E;AACA,iE;AACA,yD;AACA,kE;AACA,c;AACA,E;AACA,S;AACA,yE;AACA,+B;AACA,E;AACA,oE;AACA,oE;AACA,+C;AACA,E;AACA,kE;AACA,mE;AACA,mE;AACA,sE;AACA,iE;AACA,E;AACA,wB;AACA,E;AACA,qE;AACA,gE;AACA,yD;AACA,kE;;AAEA,mB;;AAEA,+C;AACA,6C;;AAEA,2B;AACA,uC;AACA,sD;AACA,oD;AACA,2C;AACA,oD;AACA,yC;AACA,sC;AACA,4C;AACA,gC;AACA,0C;AACA,Q;AACA,sC;AACA,I;AACA,qC;AACA,0C;AACA,+B;AACA,yC;AACA,Q;AACA,sC;AACA,I;AACA,+C;AACA,4B;AACA,qD;AACA,I;;AAEA,wB;;AAEA,wB;AACA,kC;AACA,kC;AACA,0B;AACA,iB;AACA,2D;AACA,gE;AACA,4D;AACA,6C;AACA,gD;AACA,4B;AACA,8E;AACA,yD;AACA,mB;AACA,sC;AACA,mD;AACA,iE;AACA,kE;AACA,iE;AACA,uD;AACA,gC;AACA,qC;AACA,sC;AACA,+C;AACA,K;AACA,G;;AAEA,e;AACA,E;;AAEA,gC;AACA,gC;AACA,yC;AACA,qC;AACA,kE;AACA,wD;AACA,0C;AACA,4E;AACA,2C;AACA,K;AACA,K;AACA,E;;AAEA,0D;AACA,S;AACA,2B;AACA,a;AACA,uC;AACA,2D;AACA,0D;AACA,c;AACA,E;;AAEA,oB;;;AAGA,qB;;AAEA,8D;AACA,mE;AACA,+B;AACA,E;AACA,kE;AACA,4D;AACA,2D;AACA,iE;AACA,mE;AACA,8D;AACA,qC;AACA,E;AACA,iE;AACA,+D;AACA,W;AACA,E;AACA,wB;AACA,W;AACA,kB;AACA,sB;AACA,qB;AACA,2B;AACA,yB;AACA,E;AACA,iE;AACA,sE;AACA,oC;AACA,E;AACA,kB;AACA,E;AACA,mE;AACA,mE;AACA,mE;AACA,mE;AACA,yD;AACA,iE;AACA,yB;AACA,wD;AACA,wB;AACA,+C;AACA,uB;AACA,E;;AAEA,4C;AACA,kE;AACA,mE;AACA,2B;AACA,4B;AACA,4B;AACA,8B;AACA,qD;AACA,iC;AACA,gC;AACA,K;AACA,I;;AAEA,kE;AACA,wE;AACA,uB;AACA,+B;AACA,2B;AACA,8B;AACA,yB;AACA,6B;AACA,mC;AACA,K;AACA,I;;AAEA,oE;AACA,kE;AACA,oE;AACA,mE;AACA,yC;AACA,I;AACA,+D;AACA,kE;AACA,kE;AACA,oE;AACA,gE;AACA,gC;AACA,I;AACA,sE;AACA,kC;AACA,I;AACA,+D;AACA,mE;AACA,iE;AACA,8B;AACA,yC;AACA,mE;AACA,4B;AACA,a;AACA,yC;;AAEA,iF;AACA,qE;AACA,gE;AACA,wE;AACA,U;AACA,kC;AACA,+D;AACA,oE;AACA,sE;AACA,wE;AACA,mD;AACA,4B;AACA,4D;AACA,iD;AACA,W;AACA,O;AACA,K;AACA,I;;AAEA,iE;AACA,mB;AACA,wB;AACA,oB;;AAEA,2C;AACA,gD;AACA,4B;AACA,O;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC1PA,gE;AACA,qE;AACA,2B;AACA,E;AACA,qE;AACA,uE;AACA,mE;AACA,iD;;AAEA,yB;AACA,4B;AACA,kC;;AAEA,mE;;AAEA,Y;AACA,uD;AACA,yB;AACA,4D;;AAEA,iD;AACA,mD;;AAEA,kE;AACA,gE;AACA,oC;AACA,I;AACA,+D;AACA,mE;AACA,mE;AACA,iE;AACA,+D;AACA,I;AACA,kE;AACA,wC;AACA,I;AACA,mE;AACA,8D;AACA,iE;AACA,mE;AACA,mB;AACA,uE;AACA,iD;;AAEA,oE;AACA,uD;AACA,4E;AACA,kD;AACA,E;;AAEA,sD;AACA,iC;AACA,mD;AACA,I;;AAEA,+B;AACA,gD;AACA,I;;AAEA,yC;AACA,wC;AACA,I;;AAEA,qC;AACA,qB;;AAEA,kE;AACA,sD;;AAEA,qD;AACA,2B;AACA,4B;AACA,+B;AACA,6B;AACA,kE;AACA,6B;AACA,0B;AACA,mC;AACA,yB;AACA,K;AACA,uC;AACA,gC;AACA,8B;AACA,qC;AACA,6B;AACA,K;;AAEA,yB;AACA,4B;AACA,2B;AACA,K;;AAEA,e;AACA,I;;AAEA,6B;AACA,oB;AACA,mC;AACA,2E;AACA,kE;AACA,O;AACA,I;;AAEA,+B;AACA,oB;AACA,mC;AACA,uC;AACA,qE;AACA,O;AACA,O;AACA,I;;AAEA,8B;AACA,4D;AACA,6C;;AAEA,0B;AACA,gC;AACA,8B;;AAEA,4D;;AAEA,oE;AACA,iE;AACA,iE;AACA,+B;AACA,kB;AACA,kB;AACA,qB;AACA,2D;AACA,2D;AACA,0B;AACA,Q;AACA,K;;AAEA,iC;AACA,2B;AACA,iE;AACA,oB;AACA,uC;AACA,gE;AACA,W;AACA,Q;AACA,U;AACA,I;;AAEA,6B;AACA,4E;AACA,iD;AACA,iE;AACA,2B;AACA,gC;AACA,M;;AAEA,kE;AACA,+C;AACA,uD;AACA,qC;AACA,oD;AACA,2C;AACA,mD;AACA,oE;AACA,mC;AACA,qD;AACA,uC;AACA,sD;AACA,O;AACA,K;AACA,kE;AACA,qD;AACA,4D;AACA,8B;AACA,iB;AACA,O;AACA,kE;AACA,kE;AACA,8B;AACA,iB;AACA,O;AACA,K;AACA,uC;AACA,uE;AACA,8B;AACA,iB;AACA,O;AACA,K;;AAEA,wB;;AAEA,qD;AACA,uC;AACA,wD;AACA,kE;AACA,kD;AACA,yD;AACA,uD;AACA,sD;AACA,iC;AACA,wD;AACA,qC;AACA,0D;AACA,uC;AACA,8D;AACA,O;AACA,2C;AACA,8D;AACA,O;AACA,K;;AAEA,qC;AACA,6C;AACA,K;AACA,oC;AACA,6C;AACA,sD;AACA,O;AACA,6C;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC3NA,kE;AACA,wC;AACA,E;AACA,mE;AACA,kE;AACA,iE;AACA,kE;AACA,qE;AACA,E;AACA,qE;AACA,qE;AACA,+D;AACA,4D;AACA,oE;AACA,4D;AACA,E;AACA,uE;AACA,kE;AACA,iE;AACA,uD;;AAEA,mE;;AAEA,Y;AACA,sD;AACA,kB;AACA,yB;AACA,qC;AACA,kC;AACA,I;;AAEA,kE;AACA,mE;AACA,uE;AACA,uE;AACA,sB;AACA,yD;AACA,2B;AACA,uC;AACA,kC;AACA,qC;AACA,kC;AACA,gE;AACA,gE;AACA,sB;AACA,K;AACA,E;;AAEA,qD;AACA,4B;AACA,2B;AACA,I;;AAEA,+B;AACA,2B;AACA,I;;AAEA,yC;AACA,mD;AACA,yD;AACA,+C;AACA,2B;;AAEA,yC;AACA,gC;;AAEA,gE;AACA,uD;;AAEA,oD;AACA,4C;AACA,K;AACA,I;;AAEA,mC;AACA,uB;;AAEA,0D;AACA,2B;AACA,8B;AACA,+B;AACA,+B;AACA,yD;AACA,mC;AACA,wD;AACA,kD;AACA,sC;AACA,8D;AACA,qC;AACA,iC;AACA,mC;AACA,sC;;AAEA,yC;AACA,2C;AACA,I;;AAEA,2E;AACA,8E;AACA,I;AACA,uE;AACA,mE;AACA,+C;AACA,4B;AACA,+C;AACA,2C;AACA,yB;AACA,kC;AACA,2B;AACA,M;;;AAGA,6B;AACA,0B;AACA,8C;AACA,0B;AACA,4B;AACA,4E;AACA,+B;AACA,uB;;AAEA,wD;AACA,kD;AACA,yE;AACA,wE;AACA,yE;AACA,2C;AACA,kD;AACA,6B;AACA,sC;AACA,mC;AACA,qC;AACA,iC;AACA,2C;AACA,2C;AACA,6C;AACA,6C;AACA,qC;AACA,gD;AACA,O;AACA,K;AACA,uD;AACA,kD;AACA,sC;AACA,yD;AACA,kC;AACA,8E;AACA,a;AACA,K;;AAEA,sB;AACA,mD;AACA,mC;AACA,K;AACA,wD;AACA,mC;AACA,K;;AAEA,wB;AACA,G;;AAEA,G","sourcesContent":["// Meteor Universal Events -- Normalized cross-browser event handling library\r\n//\r\n// This module lets you set up a function f that will be called\r\n// whenever an event fires on any element in the DOM. Specifically,\r\n// when an event fires on node N, f will be called with N. Then, if\r\n// the event is a bubbling event, f will be called again with N's\r\n// parent, then called again with N's grandparent, etc, until the root\r\n// of the document is reached. This provides a good base on top of\r\n// which custom event handling systems can be implemented.\r\n//\r\n// f also receives the event object for the event that fired. The\r\n// event object is normalized and extended to smooth over\r\n// cross-browser differences in event handling. See the details in\r\n// setHandler.\r\n//\r\n// Usage:\r\n//   var listener = new UniversalEventListener(function (event) { ... });\r\n//   listener.addType(\"click\");\r\n//\r\n// If you want to support IE <= 8, you must also call installHandler\r\n// on each subtree of DOM nodes on which you wish to receive events,\r\n// eg, before inserting them into the document.\r\n//\r\n// Universal Events works reliably for events that fire on any DOM\r\n// element. It may not work consistently across browsers for events\r\n// that are intended to fire on non-element nodes (eg, text nodes).\r\n// We're not sure if it's possible to handle those events consistently\r\n// across browsers, but in any event, it's not a common use case.\r\n//\r\n// Implementation notes:\r\n//\r\n// Internally, there are two separate implementations, one for modern\r\n// browsers (in events-w3c.js), and one for old browsers with no\r\n// event capturing support (in events-ie.js.) The correct\r\n// implementation will be chosen for you automatically at runtime.\r\n\r\nvar listeners = [];\r\n\r\nvar returnFalse = function() { return false; };\r\nvar returnTrue = function() { return true; };\r\n\r\n// inspired by jquery fix()\r\nvar normalizeEvent = function (event) {\r\n  var originalStopPropagation = event.stopPropagation;\r\n  var originalPreventDefault = event.preventDefault;\r\n  event.isPropagationStopped = returnFalse;\r\n  event.isImmediatePropagationStopped = returnFalse;\r\n  event.isDefaultPrevented = returnFalse;\r\n  event.stopPropagation = function() {\r\n    event.isPropagationStopped = returnTrue;\r\n    if (originalStopPropagation)\r\n      originalStopPropagation.call(event);\r\n    else\r\n      event.cancelBubble = true; // IE\r\n  };\r\n  event.preventDefault = function() {\r\n    event.isDefaultPrevented = returnTrue;\r\n    if (originalPreventDefault)\r\n      originalPreventDefault.call(event);\r\n    else\r\n      event.returnValue = false; // IE\r\n  };\r\n  event.stopImmediatePropagation = function() {\r\n    event.stopPropagation();\r\n    event.isImmediatePropagationStopped = returnTrue;\r\n  };\r\n\r\n  var type = event.type;\r\n\r\n  // adapted from jquery\r\n  if (event.metaKey === undefined)\r\n    event.metaKey = event.ctrlKey;\r\n  if (/^key/.test(type)) {\r\n    // KEY EVENTS\r\n    // Add which.  Technically char codes and key codes are\r\n    // different things; the former is ASCII/unicode/etc and the\r\n    // latter is arbitrary.  But browsers that lack charCode\r\n    // seem to put character info in keyCode.\r\n    // (foo == null) tests for null or undefined\r\n    if (event.which == null)\r\n      event.which = (event.charCode != null ? event.charCode : event.keyCode);\r\n  } else if (/^(?:mouse|contextmenu)|click/.test(type)) {\r\n    // MOUSE EVENTS\r\n    // Add relatedTarget, if necessary\r\n    if (! event.relatedTarget && event.fromElement)\r\n      event.relatedTarget = (event.fromElement === event.target ?\r\n                             event.toElement : event.fromElement);\r\n    // Add which for click: 1 === left; 2 === middle; 3 === right\r\n    if (! event.which && event.button !== undefined ) {\r\n      var button = event.button;\r\n      event.which = (button & 1 ? 1 :\r\n                     (button & 2 ? 3 :\r\n                       (button & 4 ? 2 : 0 )));\r\n    }\r\n  }\r\n\r\n  return event;\r\n};\r\n\r\nvar deliver = function (event) {\r\n  event = normalizeEvent(event);\r\n  _.each(listeners, function (listener) {\r\n    if (listener.types[event.type]) {\r\n      // if in debug mode, filter out events where the user forgot\r\n      // to call installHandler, even if we're not on IE\r\n      if (!(listener._checkIECompliance &&\r\n            ! event.currentTarget['_uevents_test_eventtype_' + event.type]))\r\n        listener.handler.call(null, event);\r\n    }\r\n  });\r\n};\r\n\r\n// When IE8 is dead, we can remove this springboard logic.\r\nvar impl;\r\nvar getImpl = function () {\r\n  if (! impl)\r\n    impl = (document.addEventListener ?\r\n            new UniversalEventListener._impl.w3c(deliver) :\r\n            new UniversalEventListener._impl.ie(deliver));\r\n  return impl;\r\n};\r\n\r\nvar typeCounts = {};\r\n\r\n\r\n////////// PUBLIC API\r\n\r\n// Create a new universal event listener with a given handler.\r\n// Until some event types are turned on with `addType`, the handler\r\n// will not receive any events.\r\n//\r\n// Whenever an event of the appropriate type fires anywhere in the\r\n// document, `handler` will be called with one argument, the\r\n// event. If the event is a bubbling event (most events are\r\n// bubbling, eg, 'click'), then `handler` will be called not only\r\n// for the element that was the origin of the event (eg, the button\r\n// that was clicked), but for each parent element as the event\r\n// bubbles up to the top of the tree.\r\n//\r\n// The event object that's passed to `handler` will be normalized\r\n// across browsers so that it contains the following fields and\r\n// methods:\r\n//\r\n// - type (e.g. \"click\")\r\n// - target\r\n// - currentTarget\r\n// - stopPropagation()\r\n// - preventDefault()\r\n// - isPropagationStopped()\r\n// - isDefaultPrevented()\r\n//\r\n// NOTE: If you want compatibility with IE <= 8, you will need to\r\n// call `installHandler` to prepare each subtree of the DOM to receive\r\n// the events you are interested in.\r\n//\r\n// Debugging only:\r\n//\r\n// The _checkIECompliance flag enables extra checking that the user\r\n// is correctly registering new DOM nodes with installHandler, even\r\n// in browsers that don't require it. In other words, when the flag\r\n// is set, modern browsers will require the same API calls as IE <=\r\n// 8. This is only used for tests and is private for now.\r\nUniversalEventListener = function (handler, _checkIECompliance) {\r\n  this.handler = handler;\r\n  this.types = {}; // map from event type name to 'true'\r\n  this.impl = getImpl();\r\n  this._checkIECompliance = _checkIECompliance;\r\n  listeners.push(this);\r\n};\r\n\r\n_.extend(UniversalEventListener.prototype, {\r\n  // Adds `type` to the set of event types that this listener will\r\n  // listen to and deliver to the handler.  Has no effect if `type`\r\n  // is already in the set.\r\n  addType: function (type) {\r\n    if (!this.types[type]) {\r\n      this.types[type] = true;\r\n      typeCounts[type] = (typeCounts[type] || 0) + 1;\r\n      if (typeCounts[type] === 1)\r\n        this.impl.addType(type);\r\n    }\r\n  },\r\n\r\n  // Removes `type` from the set of event types that this listener\r\n  // will listen to and deliver to the handler.  Has no effect if `type`\r\n  // is not in the set.\r\n  removeType: function (type) {\r\n    if (this.types[type]) {\r\n      delete this.types[type];\r\n      typeCounts[type]--;\r\n      if (! typeCounts[type])\r\n        this.impl.removeType(type);\r\n    }\r\n  },\r\n\r\n  // It is only necessary to call this method if you want to support\r\n  // IE <= 8. On those browsers, you must call this method on each\r\n  // set of nodes before adding them to the DOM (or at least, before\r\n  // expecting to receive events on them), and you must specify the\r\n  // types of events you'll be receiving.\r\n  //\r\n  // `node` and all of its descendents will be set up to handle\r\n  // events of type `type` (eg, 'click'). Only current descendents\r\n  // of `node` are affected; if new nodes are added to the subtree\r\n  // later, installHandler must be called again to ensure events are\r\n  // received on those nodes. To set up to handle multiple event\r\n  // types, make multiple calls.\r\n  //\r\n  // It is safe to call installHandler any number of times on the same\r\n  // arguments (it is idempotent).\r\n  //\r\n  // If you forget to call this function for a given node, it's\r\n  // unspecified whether you'll receive events on IE <= 8 (you may,\r\n  // you may not.) If you don't care about supporting IE <= 8 you\r\n  // can ignore this function.\r\n  installHandler: function (node, type) {\r\n    // Only work on element nodes, not e.g. text nodes or fragments\r\n    if (node.nodeType !== 1)\r\n      return;\r\n    this.impl.installHandler(node, type);\r\n\r\n    // When in checkIECompliance mode, mark all the nodes in the current subtree.\r\n    // We will later block events on nodes that weren't marked.  This\r\n    // tests that Spark is generating calls to registerEventType\r\n    // with proper subtree information, even in browsers that don't need\r\n    // it.\r\n    if (this._checkIECompliance) {\r\n      // set flag to mark the node for this type, recording the\r\n      // fact that installHandler was called for this node and type.\r\n      // the property value can be any non-primitive value (to prevent\r\n      // showing up as an HTML attribute in IE) so we use `node` itself.\r\n      node['_uevents_test_eventtype_'+type] = node;\r\n      if (node.firstChild) {\r\n        _.each(node.getElementsByTagName('*'), function(x) {\r\n          x['_uevents_test_eventtype_'+type] = x;\r\n        });\r\n      }\r\n    }\r\n  },\r\n\r\n  // Tear down this UniversalEventListener so that no more events\r\n  // are delivered.\r\n  destroy: function () {\r\n    var self = this;\r\n\r\n    listeners = _.without(listeners, self);\r\n    _.each(_.keys(self.types), function (type) {\r\n      self.removeType(type);\r\n    });\r\n  }\r\n});\r\n","// Universal Events implementation that depends on the W3C event\r\n// model, i.e. addEventListener and capturing.  It's intended for all\r\n// browsers except IE <= 8.\r\n//\r\n// We take advantage of the fact that event handlers installed during\r\n// the capture phase are live during the bubbling phase.  By installing\r\n// a capturing listener on the document, we bind the handler to the\r\n// event target and its ancestors \"just in time\".\r\n\r\nvar SIMULATE_NEITHER = 0;\r\nvar SIMULATE_FOCUS_BLUR = 1;\r\nvar SIMULATE_FOCUSIN_FOCUSOUT = 2;\r\n\r\nUniversalEventListener._impl = UniversalEventListener._impl ||  {};\r\n\r\n// Singleton\r\nUniversalEventListener._impl.w3c = function (deliver) {\r\n  this.deliver = deliver;\r\n  this.typeCounts = {}; // map from event type name to count\r\n\r\n  this.boundHandler = _.bind(this.handler, this);\r\n  this.boundCapturer = _.bind(this.capturer, this);\r\n\r\n  // Focusin/focusout are the bubbling versions of focus/blur, and\r\n  // are part of the W3C spec, but are absent from Firefox as of\r\n  // today (v11), so we supply them.\r\n  //\r\n  // In addition, while most browsers fire these events sync in\r\n  // response to a programmatic action (like .focus()), not all do.\r\n  // IE 9+ fires focusin/focusout sync but focus/blur async.  Opera\r\n  // fires them all async.  We don't do anything about this right\r\n  // now, but simulating focus/blur on IE would make them sync.\r\n  //\r\n  // We have the capabiilty here to simulate focusin/focusout from\r\n  // focus/blur, vice versa, or neither.\r\n  //\r\n  // We do a browser check that fails in old Firefox (3.6) but will\r\n  // succeed if Firefox ever implements focusin/focusout.  Old\r\n  // Firefox fails all tests of the form ('onfoo' in node), while\r\n  // new Firefox and all other known browsers will pass if 'foo' is\r\n  // a known event.\r\n  this.focusBlurMode = ('onfocusin' in document.createElement(\"DIV\")) ?\r\n    SIMULATE_NEITHER : SIMULATE_FOCUSIN_FOCUSOUT;\r\n\r\n  // mouseenter/mouseleave is non-bubbling mouseover/mouseout.  It's\r\n  // standard but only IE and Opera seem to support it,\r\n  // so we simulate it (which works in IE but not in Opera for some reason).\r\n  this.simulateMouseEnterLeave = (! window.opera);\r\n};\r\n\r\n_.extend(UniversalEventListener._impl.w3c.prototype, {\r\n  addType: function (eventType) {\r\n    this._listen(this._expandEventType(eventType));\r\n  },\r\n\r\n  removeType: function (type) {\r\n    this._unlisten(this._expandEventType(type));\r\n  },\r\n\r\n  installHandler: function (node, type) {\r\n    // Unnecessary in w3c implementation\r\n  },\r\n\r\n  _expandEventType: function (type) {\r\n    var ret = [type];\r\n\r\n    // install handlers for the events used to fake events of this\r\n    // type, in addition to handlers for the real type\r\n\r\n    if (this.focusBlurMode === SIMULATE_FOCUS_BLUR) {\r\n      if (type === 'focus')\r\n        ret.push('focusin');\r\n      else if (type === 'blur')\r\n        ret.push('focusout');\r\n    } else if (this.focusBlurMode === SIMULATE_FOCUSIN_FOCUSOUT) {\r\n      if (type === 'focusin')\r\n        ret.push('focus');\r\n      else if (type === 'focusout')\r\n        ret.push('blur');\r\n    }\r\n    if (this.simulateMouseEnterLeave) {\r\n      if (type === 'mouseenter')\r\n        ret.push('mouseover');\r\n      else if (type === 'mouseleave')\r\n        ret.push('mouseout');\r\n    }\r\n\r\n    if (type === 'tap') {\r\n      ret.push('touchmove');\r\n      ret.push('touchend');\r\n    }\r\n\r\n    return ret;\r\n  },\r\n\r\n  _listen: function (types) {\r\n    var self = this;\r\n    _.each(types, function (type) {\r\n      if ((self.typeCounts[type] = (self.typeCounts[type] || 0) + 1) === 1)\r\n        document.addEventListener(type, self.boundCapturer, true);\r\n    });\r\n  },\r\n\r\n  _unlisten: function (types) {\r\n    var self = this;\r\n    _.each(types, function (type) {\r\n      if (!(--self.typeCounts[type])) {\r\n        document.removeEventListener(type, self.boundCapturer, true);\r\n      }\r\n    });\r\n  },\r\n\r\n  capturer: function (event) {\r\n    if (event.target.nodeType === 3) // fix text-node target\r\n      event.target = event.target.parentNode;\r\n\r\n    var type = event.type;\r\n    var bubbles = event.bubbles;\r\n    var target = event.target;\r\n\r\n    target.addEventListener(type, this.boundHandler, false);\r\n\r\n    // According to the DOM event spec, if the DOM is mutated during\r\n    // event handling, the original bubbling order still applies.\r\n    // So we can determine the chain of nodes that could possibly\r\n    // be bubbled to right now.\r\n    var ancestors;\r\n    if (bubbles) {\r\n      ancestors = [];\r\n      for(var n = target.parentNode; n; n = n.parentNode) {\r\n        n.addEventListener(type, this.boundHandler, false);\r\n        ancestors.push(n);\r\n      };\r\n    }\r\n\r\n    // Unbind the handlers later.\r\n    setTimeout(function() {\r\n      target.removeEventListener(type, this.boundHandler, false);\r\n      if (bubbles) {\r\n        _.each(ancestors, function(n) {\r\n          n.removeEventListener(type, this.boundHandler, false);\r\n        });\r\n      };\r\n    }, 0);\r\n  },\r\n\r\n  handler: function (event) {\r\n    var sendUIEvent = function (type, target, bubbles, cancelable, detail) {\r\n      var evt = document.createEvent(\"UIEvents\");\r\n      evt.initUIEvent(type, bubbles, cancelable, window, detail);\r\n      evt.synthetic = true;\r\n      target.dispatchEvent(evt);\r\n    };\r\n\r\n    // fire synthetic focusin/focusout on blur/focus or vice versa\r\n    if (event.currentTarget === event.target) {\r\n      if (this.focusBlurMode === SIMULATE_FOCUS_BLUR) {\r\n        if (event.type === 'focusin')\r\n          sendUIEvent('focus', event.target, false);\r\n        else if (event.type === 'focusout')\r\n          sendUIEvent('blur', event.target, false);\r\n      } else if (this.focusBlurMode === SIMULATE_FOCUSIN_FOCUSOUT) {\r\n        if (event.type === 'focus')\r\n          sendUIEvent('focusin', event.target, true);\r\n        else if (event.type === 'blur')\r\n          sendUIEvent('focusout', event.target, true);\r\n      }\r\n    }\r\n    // only respond to synthetic events of the types we are faking\r\n    if (this.focusBlurMode === SIMULATE_FOCUS_BLUR) {\r\n      if (event.type === 'focus' || event.type === 'blur') {\r\n        if (! event.synthetic)\r\n          return;\r\n      }\r\n    } else if (this.focusBlurMode === SIMULATE_FOCUSIN_FOCUSOUT) {\r\n      if (event.type === 'focusin' || event.type === 'focusout') {\r\n        if (! event.synthetic)\r\n          return;\r\n      }\r\n    }\r\n    if (this.simulateMouseEnterLeave) {\r\n      if (event.type === 'mouseenter' || event.type === 'mouseleave') {\r\n        if (! event.synthetic)\r\n          return;\r\n      }\r\n    }\r\n\r\n    this.deliver(event);\r\n\r\n    // event ordering: fire mouseleave after mouseout\r\n    if (this.simulateMouseEnterLeave &&\r\n        // We respond to mouseover/mouseout here even on\r\n        // bubble, i.e. when event.currentTarget !== event.target,\r\n        // to ensure we see every enter and leave.\r\n        // We ignore the case where the mouse enters from\r\n        // a child or leaves to a child (by checking if\r\n        // relatedTarget is present and a descendent).\r\n        (! event.relatedTarget ||\r\n         (event.currentTarget !== event.relatedTarget &&\r\n          ! DomUtils.elementContains(\r\n            event.currentTarget, event.relatedTarget)))) {\r\n      if (event.type === 'mouseover') {\r\n        sendUIEvent('mouseenter', event.currentTarget, false);\r\n      }\r\n      else if (event.type === 'mouseout') {\r\n        sendUIEvent('mouseleave', event.currentTarget, false);\r\n      }\r\n    }\r\n\r\n    if (event.type === 'touchmove') {\r\n      event.currentTarget._notTapping = true;\r\n    }\r\n    if (event.type === 'touchend') {\r\n      if (!event.currentTarget._notTapping) {\r\n        sendUIEvent('tap', event.currentTarget, true);\r\n      }\r\n      delete event.currentTarget._notTapping;\r\n    }\r\n  }\r\n});\r\n","// Universal Events implementation for IE versions 6-8, which lack\r\n// addEventListener and event capturing.\r\n//\r\n// The strategy is very different.  We walk the subtree in question\r\n// and just attach the handler to all elements.  If the handler is\r\n// foo and the eventType is 'click', we assign node.onclick = foo\r\n// everywhere.  Since there is only one function object and we are\r\n// just assigning a property, hopefully this is somewhat lightweight.\r\n//\r\n// We use the node.onfoo method of binding events, also called \"DOM0\"\r\n// or the \"traditional event registration\", rather than the IE-native\r\n// node.attachEvent(...), mainly because we have the benefit of\r\n// referring to `this` from the handler in order to populate\r\n// event.currentTarget.  It seems that otherwise we'd have to create\r\n// a closure per node to remember what node we are handling.\r\n//\r\n// We polyfill the usual event properties from their various locations.\r\n// We also make 'change' and 'submit' bubble, and we fire 'change'\r\n// events on checkboxes and radio buttons immediately rather than\r\n// only when the user blurs them, another old IE quirk.\r\n\r\nUniversalEventListener._impl = UniversalEventListener._impl ||  {};\r\n\r\n// Singleton\r\nUniversalEventListener._impl.ie = function (deliver) {\r\n  var self = this;\r\n  this.deliver = deliver;\r\n  this.curriedHandler = function () {\r\n    self.handler.call(this, self);\r\n  };\r\n\r\n  // The 'submit' event on IE doesn't bubble.  We want to simulate\r\n  // bubbling submit to match other browsers, and to do that we use\r\n  // IE's own event machinery.  We can't dispatch events with arbitrary\r\n  // names in IE, so we appropriate the obscure \"datasetcomplete\" event\r\n  // for this purpose.\r\n  document.attachEvent('ondatasetcomplete', function () {\r\n    var evt = window.event;\r\n    var target = evt && evt.srcElement;\r\n    if (evt.synthetic && target &&\r\n        target.nodeName === 'FORM' &&\r\n        evt.returnValue !== false)\r\n      // No event handler called preventDefault on the simulated\r\n      // submit event.  That means the form should be submitted.\r\n      target.submit();\r\n  });\r\n};\r\n\r\n_.extend(UniversalEventListener._impl.ie.prototype, {\r\n  addType: function (type) {\r\n    // not necessary for IE\r\n  },\r\n\r\n  removeType: function (type) {\r\n    // not necessary for IE\r\n  },\r\n\r\n  installHandler: function (node, type) {\r\n    // use old-school event binding, so that we can\r\n    // access the currentTarget as `this` in the handler.\r\n    // note: handler is never removed from node\r\n    var prop = 'on' + type;\r\n\r\n    if (node.nodeType === 1) { // ELEMENT\r\n      this._install(node, prop);\r\n\r\n      // hopefully fast traversal, since the browser is doing it\r\n      var descendents = node.getElementsByTagName('*');\r\n\r\n      for(var i=0, N = descendents.length; i<N; i++)\r\n        this._install(descendents[i], prop);\r\n    }\r\n  },\r\n\r\n  _install: function (node, prop) {\r\n    var props = [prop];\r\n\r\n    // install handlers for faking focus/blur if necessary\r\n    if (prop === 'onfocus')\r\n      props.push('onfocusin');\r\n    else if (prop === 'onblur')\r\n      props.push('onfocusout');\r\n    // install handlers for faking bubbling change/submit\r\n    else if (prop === 'onchange') {\r\n      // if we're looking at a checkbox or radio button,\r\n      // sign up for propertychange and NOT change\r\n      if (node.nodeName === 'INPUT' &&\r\n          (node.type === 'checkbox' || node.type === 'radio'))\r\n        props = ['onpropertychange'];\r\n      props.push('oncellchange');\r\n    } else if (prop === 'onsubmit')\r\n      props.push('ondatasetcomplete');\r\n\r\n    for(var i = 0; i < props.length; i++)\r\n      node[props[i]] = this.curriedHandler;\r\n  },\r\n\r\n  // This is the handler we assign to DOM nodes, so it shouldn't close over\r\n  // anything that would create a circular reference leading to a memory leak.\r\n  //\r\n  // This handler is called via this.curriedHandler. When it is called:\r\n  //  - 'this' is the node currently handling the event (set by IE)\r\n  //  - 'self' is what would normally be 'this'\r\n  handler: function (self) {\r\n    var sendEvent = function (ontype, target) {\r\n      var e = document.createEventObject();\r\n      e.synthetic = true;\r\n      target.fireEvent(ontype, e);\r\n      return e.returnValue;\r\n    };\r\n\r\n\r\n    var event = window.event;\r\n    var type = event.type;\r\n    var target = event.srcElement || document;\r\n    event.target = target;\r\n    if (this.nodeType !== 1)\r\n      return; // sanity check that we have a real target (always an element)\r\n    event.currentTarget = this;\r\n    var curNode = this;\r\n\r\n    // simulate focus/blur so that they are synchronous;\r\n    // simulate change/submit so that they bubble.\r\n    // The IE-specific 'cellchange' and 'datasetcomplete' events actually\r\n    // have nothing to do with change and submit, we are just using them\r\n    // as dummy events because we need event types that IE considers real\r\n    // (and apps are unlikely to use them).\r\n    if (curNode === target && ! event.synthetic) {\r\n      if (type === 'focusin')\r\n        sendEvent('onfocus', curNode);\r\n      else if (type === 'focusout')\r\n        sendEvent('onblur', curNode);\r\n      else if (type === 'change')\r\n        sendEvent('oncellchange', curNode);\r\n      else if (type === 'propertychange') {\r\n        if (event.propertyName === 'checked')\r\n          sendEvent('oncellchange', curNode);\r\n      } else if (type === 'submit') {\r\n        sendEvent('ondatasetcomplete', curNode);\r\n      }\r\n    }\r\n    // ignore non-simulated events of types we simulate\r\n    if ((type === 'focus' || event.type === 'blur'\r\n         || event.type === 'change' ||\r\n         event.type === 'submit') && ! event.synthetic) {\r\n      if (event.type === 'submit')\r\n        event.returnValue = false; // block all native submits, we will submit\r\n      return;\r\n    }\r\n\r\n    // morph the event\r\n    if (type === 'cellchange' && event.synthetic) {\r\n      type = event.type = 'change';\r\n    }\r\n    if (type === 'datasetcomplete' && event.synthetic) {\r\n      type = event.type = 'submit';\r\n    }\r\n\r\n    self.deliver(event);\r\n  }\r\n\r\n});\r\n"]}