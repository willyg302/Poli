)]}'
{"version":3,"file":"\\packages\\domutils.js","sources":["domutils/domutils.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,6D;AACA,yD;AACA,yC;AACA,kC;AACA,sE;;AAEA,4D;AACA,kD;AACA,6B;;AAEA,uB;AACA,oD;AACA,2B;AACA,+D;AACA,2C;AACA,0E;AACA,wC;AACA,mB;AACA,yD;AACA,O;AACA,E;;AAEA,mE;AACA,qE;AACA,E;AACA,6E;AACA,yE;AACA,oC;AACA,gC;AACA,E;AACA,qB;AACA,sC;AACA,iE;AACA,kD;;AAEA,yD;;AAEA,4C;AACA,wE;AACA,sE;AACA,oB;AACA,kD;AACA,2E;AACA,wD;;AAEA,wD;AACA,c;AACA,wD;AACA,+D;;AAEA,iD;AACA,mE;;AAEA,uE;AACA,8D;;AAEA,+D;AACA,yE;;AAEA,6E;;AAEA,wE;AACA,sE;AACA,+B;AACA,yC;AACA,kE;AACA,E;;AAEA,8C;AACA,e;AACA,6D;AACA,6C;AACA,sC;AACA,kD;AACA,2D;AACA,wE;AACA,iC;AACA,yB;AACA,E;AACA,mB;AACA,2B;AACA,uB;AACA,uB;AACA,0B;AACA,yB;AACA,gB;AACA,G;AACA,sB;AACA,wE;AACA,iD;AACA,C;;AAEA,gC;AACA,0F;AACA,2B;AACA,uB;AACA,wB;AACA,wC;;;AAGA,mE;AACA,iC;AACA,2C;AACA,qC;AACA,0C;;AAEA,sB;AACA,wB;AACA,kC;AACA,iB;AACA,+C;AACA,U;AACA,oB;AACA,gC;AACA,gD;AACA,kD;AACA,4C;AACA,yE;AACA,yD;AACA,oD;AACA,8B;AACA,0D;AACA,4D;AACA,mE;AACA,8D;AACA,2C;AACA,K;;AAEA,6C;AACA,qC;AACA,mC;AACA,+C;AACA,8B;AACA,uB;AACA,sC;AACA,K;;AAEA,uD;AACA,sD;AACA,4D;AACA,oC;AACA,6B;AACA,iC;AACA,sC;AACA,S;AACA,S;AACA,K;;AAEA,yC;AACA,kD;AACA,oB;AACA,8D;AACA,qD;AACA,O;AACA,K;;AAEA,8B;AACA,yD;AACA,wB;AACA,mE;AACA,oE;AACA,iB;AACA,mE;AACA,oE;AACA,sD;AACA,6B;AACA,S;AACA,S;;AAEA,2C;AACA,kE;AACA,gD;AACA,2C;AACA,oE;AACA,wD;AACA,+F;AACA,kE;AACA,+C;AACA,2D;AACA,S;AACA,sD;AACA,uD;AACA,4E;AACA,yE;AACA,qD;AACA,2C;AACA,oD;AACA,2C;AACA,mC;AACA,mD;AACA,+C;AACA,4E;AACA,4C;AACA,oD;AACA,iC;AACA,8C;AACA,W;AACA,S;;AAEA,4B;AACA,kC;AACA,kD;AACA,kB;AACA,0D;AACA,S;AACA,K;;AAEA,8C;AACA,gC;AACA,6C;AACA,G;;AAEA,c;AACA,E;;AAEA,2D;AACA,2D;AACA,yC;AACA,2C;AACA,kE;;AAEA,sD;AACA,E;;AAEA,iE;AACA,mE;AACA,gE;AACA,oE;AACA,gC;AACA,gD;AACA,qC;;AAEA,qC;AACA,uD;AACA,4C;AACA,G;;AAEA,2C;;AAEA,uB;AACA,e;AACA,gC;AACA,U;AACA,yC;AACA,yD;;AAEA,oD;AACA,8B;AACA,uB;AACA,sC;AACA,K;;AAEA,gC;AACA,G;;AAEA,mB;AACA,E;;AAEA,+D;AACA,4C;AACA,qC;AACA,iB;AACA,c;AACA,iB;;AAEA,kC;AACA,+C;AACA,U;AACA,+D;AACA,0E;AACA,gE;AACA,yC;AACA,qB;AACA,gD;AACA,mB;AACA,gB;AACA,kB;;AAEA,yB;AACA,G;AACA,E;;AAEA,+D;AACA,2D;AACA,iE;AACA,6D;AACA,+D;AACA,mE;AACA,6D;AACA,U;AACA,E;AACA,yE;AACA,qD;AACA,2D;AACA,yC;AACA,M;AACA,wE;AACA,sE;AACA,sE;AACA,uE;AACA,uB;AACA,2B;AACA,uD;AACA,yD;AACA,+B;AACA,gC;AACA,6C;AACA,mB;AACA,G;;AAEA,kD;AACA,E;;AAEA,0D;AACA,kD;AACA,wD;AACA,8C;AACA,E;;AAEA,gE;AACA,4D;AACA,gD;AACA,iB;AACA,0D;AACA,gE;AACA,uD;AACA,E;;AAEA,8D;AACA,sE;AACA,oE;AACA,qE;AACA,qE;AACA,iE;AACA,E;AACA,sE;AACA,uC;AACA,E;AACA,4D;AACA,e;AACA,gF;;AAEA,8E;AACA,0E;AACA,2B;AACA,2D;AACA,sC;AACA,yD;AACA,sC;AACA,+B;AACA,+E;;AAEA,yE;AACA,mD;AACA,4D;;AAEA,qE;AACA,kB;AACA,6C;AACA,yD;AACA,K;AACA,E;;AAEA,iE;AACA,6E;AACA,wC;AACA,+C;AACA,8C;AACA,E;;AAEA,yE;AACA,4D;AACA,sE;AACA,uD;AACA,uB;AACA,qC;AACA,wC;AACA,oB;AACA,G;AACA,O;AACA,yE;AACA,gD;AACA,a;AACA,iB;AACA,oC;AACA,G;AACA,E;;AAEA,2E;AACA,gE;AACA,mC;AACA,iD;AACA,gC;AACA,iD;AACA,6B;AACA,iE;AACA,yE;AACA,wE;AACA,gC;AACA,4D;AACA,mB;AACA,sB;AACA,sE;AACA,4D;AACA,Y;AACA,gE;AACA,oC;AACA,S;;AAEA,gB;AACA,kB;AACA,G;;AAEA,e;AACA,E;;AAEA,kE;AACA,sE;AACA,qE;AACA,E;;AAEA,kE;AACA,sD;AACA,2E;AACA,iE;AACA,oE;AACA,yD;AACA,E;;AAEA,wE;AACA,sE;AACA,kB;AACA,qE;AACA,gD;AACA,2D;AACA,c;AACA,a;AACA,kC;AACA,yC;AACA,mD;AACA,U;AACA,8E;AACA,kF;AACA,sC;AACA,uC;AACA,e;AACA,oD;AACA,G;AACA,E;;AAEA,0D;AACA,iE;AACA,oE;AACA,8B;AACA,E;AACA,uD;AACA,uC;AACA,gE;AACA,oD;AACA,4B;AACA,4D;AACA,wD;AACA,+D;AACA,yD;AACA,qB;AACA,gD;AACA,4B;AACA,4B;AACA,G;AACA,E;;AAEA,iE;AACA,oE;AACA,mE;AACA,iE;AACA,yC;AACA,E;AACA,qC;AACA,yC;AACA,qD;AACA,2C;AACA,wB;AACA,gB;;AAEA,wC;AACA,2B;AACA,sC;AACA,iB;AACA,6B;AACA,gB;;AAEA,uD;AACA,E;;AAEA,yD;AACA,iD;AACA,6D;AACA,0C;AACA,uD;AACA,+C;AACA,sD;AACA,uB;AACA,wB;AACA,qD;AACA,uC;AACA,E;;AAEA,8D;AACA,0B;AACA,sC;AACA,0C;AACA,E;;AAEA,4E;AACA,kC;AACA,mD;AACA,6B;AACA,qB;AACA,yD;AACA,W;;AAEA,yE;AACA,wE;AACA,2E;AACA,8B;AACA,iD;AACA,4C;AACA,yD;AACA,iC;AACA,a;AACA,K;AACA,G;AACA,E;;AAEA,4E;AACA,kC;AACA,4C;AACA,6C;AACA,sB;;AAEA,mC;AACA,8C;AACA,oC;AACA,0D;AACA,0C;AACA,+B;AACA,kB;AACA,sE;AACA,U;AACA,sB;AACA,G;AACA,E","sourcesContent":["DomUtils = {};\r\n\r\nvar qsaFindAllBySelector = function (selector, contextNode) {\r\n  // If IE7 users report the following error message, you\r\n  // can fix it with \"meteor add jquery\".\r\n  if (! document.querySelectorAll)\r\n    throw new Error(\"This browser doesn't support querySelectorAll.\");\r\n\r\n  // the search is constrained to descendants of `ancestor`,\r\n  // but it doesn't affect the scope of the query.\r\n  var ancestor = contextNode;\r\n\r\n  return withElementId(\r\n    contextNode, \"DomUtils_findAllBySelector_scope\",\r\n    function (idSelector) {\r\n      // scope the entire selector to contextNode by prepending\r\n      // id of contextNode to the selector.\r\n      var doctoredSelector = _.map(selector.split(','), function (selec) {\r\n        return idSelector + \" \" + selec;\r\n      }).join(',');\r\n      return ancestor.querySelectorAll(doctoredSelector);\r\n    });\r\n};\r\n\r\n// We have our own, querySelectorAll-based implementation of scoped\r\n// selector matching; it's all you need in IE 8+ and modern browsers.\r\n//\r\n// However, we use Sizzle or jQuery if it's present on the client because of:\r\n// - apps that want jQuery's selector extensions (:visible, :input, etc.)\r\n// - apps that include jQuery anyway\r\n// - apps that want IE 7 support\r\n//\r\n// XXX others? zepto?\r\nvar findAllBySelector = (window.Sizzle\r\n                         || (window.jQuery && window.jQuery.find)\r\n                         || qsaFindAllBySelector);\r\n\r\n///// Common look-up tables used by htmlToFragment et al.\r\n\r\nvar testDiv = document.createElement(\"div\");\r\ntestDiv.innerHTML = \"   <link/><table></table><select><!----></select>\";\r\n// Need to wrap in a div rather than directly creating SELECT to avoid\r\n// *another* IE bug.\r\nvar testSelectDiv = document.createElement(\"div\");\r\ntestSelectDiv.innerHTML = \"<select><option selected>Foo</option></select>\";\r\ntestSelectDiv.firstChild.setAttribute(\"name\", \"myname\");\r\n\r\n// Tests that, if true, indicate browser quirks present.\r\nvar quirks = {\r\n  // IE loses initial whitespace when setting innerHTML.\r\n  leadingWhitespaceKilled: (testDiv.firstChild.nodeType !== 3),\r\n\r\n  // IE may insert an empty tbody tag in a table.\r\n  tbodyInsertion: testDiv.getElementsByTagName(\"tbody\").length > 0,\r\n\r\n  // IE loses some tags in some environments (requiring extra wrapper).\r\n  tagsLost: testDiv.getElementsByTagName(\"link\").length === 0,\r\n\r\n  // IE <= 9 loses HTML comments in <select> and <option> tags.\r\n  commentsLost: (! testDiv.getElementsByTagName(\"select\")[0].firstChild),\r\n\r\n  selectValueMustBeFromAttribute: (testSelectDiv.firstChild.value !== \"Foo\"),\r\n\r\n  // In IE7, setAttribute('name', foo) doesn't show up in rendered HTML.\r\n  // (In FF3, outerHTML is undefined, but it doesn't have this quirk.)\r\n  mustSetNameInCreateElement: (\r\n    testSelectDiv.firstChild.outerHTML &&\r\n      testSelectDiv.firstChild.outerHTML.indexOf(\"myname\") === -1)\r\n};\r\n\r\n// Set up map of wrappers for different nodes.\r\nvar wrapMap = {\r\n  option: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\r\n  legend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\r\n  thead: [ 1, \"<table>\", \"</table>\" ],\r\n  tr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\r\n  td: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\r\n  col: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\r\n  area: [ 1, \"<map>\", \"</map>\" ],\r\n  _default: [ 0, \"\", \"\" ]\r\n};\r\n_.extend(wrapMap, {\r\n  optgroup: wrapMap.option,\r\n  tbody: wrapMap.thead,\r\n  tfoot: wrapMap.thead,\r\n  colgroup: wrapMap.thead,\r\n  caption: wrapMap.thead,\r\n  th: wrapMap.td\r\n});\r\nif (quirks.tagsLost) {\r\n  // trick from jquery.  initial text is ignored when we take lastChild.\r\n  wrapMap._default = [ 1, \"div<div>\", \"</div>\" ];\r\n}\r\n\r\nvar rleadingWhitespace = /^\\s+/,\r\n    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\r\n    rtagName = /<([\\w:]+)/,\r\n    rtbody = /<tbody/i,\r\n    rhtml = /<|&#?\\w+;/,\r\n    rnoInnerhtml = /<(?:script|style)/i;\r\n\r\n\r\n// Parse an HTML string, which may contain multiple top-level tags,\r\n// and return a DocumentFragment.\r\nDomUtils.htmlToFragment = function (html) {\r\n  var doc = document; // node factory\r\n  var frag = doc.createDocumentFragment();\r\n\r\n  if (! html.length) {\r\n    // empty, do nothing\r\n  } else if (! rhtml.test(html)) {\r\n    // Just text.\r\n    frag.appendChild(doc.createTextNode(html));\r\n  } else {\r\n    // General case.\r\n    // Replace self-closing tags\r\n    html = html.replace(rxhtmlTag, \"<$1></$2>\");\r\n    // Use first tag to determine wrapping needed.\r\n    var firstTagMatch = rtagName.exec(html);\r\n    var firstTag = (firstTagMatch ? firstTagMatch[1].toLowerCase() : \"\");\r\n    var wrapData = wrapMap[firstTag] || wrapMap._default;\r\n    var fullHtml = wrapData[1] + html + wrapData[2];\r\n    if (quirks.commentsLost) {\r\n      // rewrite <select> and <option> tags into fake tags\r\n      fullHtml = fullHtml.replace(/<\\s*(select|option)\\b/ig,\r\n                                  '<ins domutilsrealtagname=\"$1\"');\r\n      fullHtml = fullHtml.replace(/<\\/\\s*(select|option)\\b/ig,\r\n                                  '</ins');\r\n    }\r\n\r\n    var container = doc.createElement(\"div\");\r\n    // insert wrapped HTML into a DIV\r\n    container.innerHTML = fullHtml;\r\n    // set \"container\" to inner node of wrapper\r\n    var unwraps = wrapData[0];\r\n    while (unwraps--) {\r\n      container = container.lastChild;\r\n    }\r\n\r\n    if (quirks.tbodyInsertion && ! rtbody.test(html)) {\r\n      // Any tbody we find was created by the browser.\r\n      var tbodies = container.getElementsByTagName(\"tbody\");\r\n      _.each(tbodies, function (n) {\r\n        if (! n.firstChild) {\r\n          // spurious empty tbody\r\n          n.parentNode.removeChild(n);\r\n        }\r\n      });\r\n    }\r\n\r\n    if (quirks.leadingWhitespaceKilled) {\r\n      var wsMatch = rleadingWhitespace.exec(html);\r\n      if (wsMatch) {\r\n        container.insertBefore(doc.createTextNode(wsMatch[0]),\r\n                               container.firstChild);\r\n      }\r\n    }\r\n\r\n    if (quirks.commentsLost) {\r\n      // replace fake select tags with real <select> tags\r\n      var fakeTags = [];\r\n      // getElementsByTagName returns a \"live\" collection, so avoid\r\n      // factorings of this code that iterate over it while mutating\r\n      // the DOM.\r\n      // Here we build an array of fake tags and iterate over that.\r\n      _.each(container.getElementsByTagName(\"ins\"), function (ins) {\r\n        if (ins.getAttribute(\"domutilsrealtagname\")) {\r\n          fakeTags.push(ins);\r\n        }\r\n      });\r\n\r\n      _.each(fakeTags, function (fakeTag) {\r\n        var tagName = fakeTag.getAttribute('domutilsrealtagname');\r\n        if (quirks.mustSetNameInCreateElement &&\r\n            fakeTag.getAttribute('name')) {\r\n          // IE7 can't set 'name' with setAttribute, but it has this\r\n          // crazy syntax for setting it at create time.\r\n          // http://webbugtrack.blogspot.com/2007/10/bug-235-createelement-is-broken-in-ie.html\r\n          // http://msdn.microsoft.com/en-us/library/ms536389.aspx\r\n          tagName = \"<\" + tagName + \" name='\" +\r\n            _.escape(fakeTag.getAttribute('name')) + \"'/>\";\r\n        }\r\n        var realTag = document.createElement(tagName);\r\n        fakeTag.removeAttribute('domutilsrealtagname');\r\n        // copy all attributes. for some reason mergeAttributes doesn't work\r\n        // here: eg, it doesn't copy SELECTED or VALUE. (Probably because\r\n        // these attributes would be expando on INS?)\r\n        var fakeAttrs = fakeTag.attributes;\r\n        for (var i = 0; i < fakeAttrs.length; ++i) {\r\n          var fakeAttr = fakeAttrs.item(i);\r\n          if (fakeAttr.specified) {\r\n            var name = fakeAttr.name.toLowerCase();\r\n            var value = String(fakeAttr.value);\r\n            // IE7 gets confused if you try to setAttribute('selected', ''),\r\n            // so be a little more explicit.\r\n            if (name === 'selected' && value === '')\r\n              value = 'selected';\r\n            realTag.setAttribute(name, value);\r\n          }\r\n        }\r\n\r\n        // move all children\r\n        while (fakeTag.firstChild)\r\n          realTag.appendChild(fakeTag.firstChild);\r\n        // replace\r\n        fakeTag.parentNode.replaceChild(realTag, fakeTag);\r\n      });\r\n    }\r\n\r\n    // Reparent children of container to frag.\r\n    while (container.firstChild)\r\n      frag.appendChild(container.firstChild);\r\n  }\r\n\r\n  return frag;\r\n};\r\n\r\n// Return an HTML string representing the contents of frag,\r\n// a DocumentFragment.  (This is what innerHTML would do if\r\n// it were defined on DocumentFragments.)\r\nDomUtils.fragmentToHtml = function (frag) {\r\n  frag = frag.cloneNode(true); // deep copy, don't touch original!\r\n\r\n  return DomUtils.fragmentToContainer(frag).innerHTML;\r\n};\r\n\r\n// Given a DocumentFragment, return a node whose children are the\r\n// reparented contents of the DocumentFragment.  In most cases this\r\n// is as simple as creating a DIV, but in the case of a fragment\r\n// containing TRs, for example, it's necessary to create a TABLE and\r\n// a TBODY and return the TBODY.\r\nDomUtils.fragmentToContainer = function (frag) {\r\n  var doc = document; // node factory\r\n\r\n  var firstElement = frag.firstChild;\r\n  while (firstElement && firstElement.nodeType !== 1) {\r\n    firstElement = firstElement.nextSibling;\r\n  }\r\n\r\n  var container = doc.createElement(\"div\");\r\n\r\n  if (! firstElement) {\r\n    // no tags!\r\n    container.appendChild(frag);\r\n  } else {\r\n    var firstTag = firstElement.nodeName;\r\n    var wrapData = wrapMap[firstTag] || wrapMap._default;\r\n\r\n    container.innerHTML = wrapData[1] + wrapData[2];\r\n    var unwraps = wrapData[0];\r\n    while (unwraps--) {\r\n      container = container.lastChild;\r\n    }\r\n\r\n    container.appendChild(frag);\r\n  }\r\n\r\n  return container;\r\n};\r\n\r\n// Returns true if element a contains node b and is not node b.\r\nDomUtils.elementContains = function (a, b) {\r\n  if (a.nodeType !== 1) /* ELEMENT */\r\n    return false;\r\n  if (a === b)\r\n    return false;\r\n\r\n  if (a.compareDocumentPosition) {\r\n    return a.compareDocumentPosition(b) & 0x10;\r\n  } else {\r\n    // Should be only old IE and maybe other old browsers here.\r\n    // Modern Safari has both functions but seems to get contains() wrong.\r\n    // IE can't handle b being a text node.  We work around this\r\n    // by doing a direct parent test now.\r\n    b = b.parentNode;\r\n    if (! (b && b.nodeType === 1)) /* ELEMENT */\r\n      return false;\r\n    if (a === b)\r\n      return true;\r\n\r\n    return a.contains(b);\r\n  }\r\n};\r\n\r\n// Returns an array containing the children of contextNode that\r\n// match `selector`. Unlike querySelectorAll, `selector` is\r\n// interpreted as if the document were rooted at `contextNode` --\r\n// the only nodes that can be used to match components of the\r\n// selector are the descendents of `contextNode`. `contextNode`\r\n// itself is not included (it can't be used to match a component of\r\n// the selector, and it can never be included in the returned\r\n// array.)\r\n//\r\n// `contextNode` may be either a node, a document, or a DocumentFragment.\r\nDomUtils.findAll = function (contextNode, selector) {\r\n  if (contextNode.nodeType === 11 /* DocumentFragment */) {\r\n    // contextNode is a DocumentFragment.\r\n    //\r\n    // We don't expect to be able to run selectors on a DocumentFragment\r\n    // (Sizzle won't work) but we can on a normal elements that aren't\r\n    // in the document.  Fortunately we can manipulate offscreen nodes\r\n    // as much as we want as long as we put them back the way they were\r\n    // when we're done.\r\n    var frag = contextNode;\r\n    var container = DomUtils.fragmentToContainer(frag);\r\n    var results = findAllBySelector(selector, container);\r\n    // put nodes back into frag\r\n    while (container.firstChild)\r\n      frag.appendChild(container.firstChild);\r\n    return results;\r\n  }\r\n\r\n  return findAllBySelector(selector, contextNode);\r\n};\r\n\r\n// Like `findAll` but finds one element (or returns null).\r\nDomUtils.find = function (contextNode, selector) {\r\n  var results = DomUtils.findAll(contextNode, selector);\r\n  return (results.length ? results[0] : null);\r\n};\r\n\r\nvar isElementInClipRange = function (elem, clipStart, clipEnd) {\r\n  // elem is not in clip range if it contains the clip range\r\n  if (DomUtils.elementContains(elem, clipStart))\r\n    return false;\r\n  // elem is in clip range if clipStart <= elem <= clipEnd\r\n  return (DomUtils.compareElementIndex(clipStart, elem) <= 0) &&\r\n    (DomUtils.compareElementIndex(elem, clipEnd) <= 0);\r\n};\r\n\r\n// Like `findAll` but searches the nodes from `start` to `end`\r\n// inclusive. `start` and `end` must be siblings, and they participate\r\n// in the search (they can be used to match selector components, and\r\n// they can appear in the returned results). It's as if the parent of\r\n// `start` and `end` serves as contextNode, but matches from children\r\n// that aren't between `start` and `end` (inclusive) are ignored.\r\n//\r\n// If `selector` involves sibling selectors, child index selectors, or\r\n// the like, the results are undefined.\r\n//\r\n// precond: clipStart/clipEnd are descendents of contextNode\r\n// XXX document\r\nDomUtils.findAllClipped = function (contextNode, selector, clipStart, clipEnd) {\r\n\r\n  // Ensure the clip range starts and ends on element nodes.  This is possible\r\n  // to do without changing the result set because non-element nodes can't\r\n  // be or contain matches.\r\n  while (clipStart !== clipEnd && clipStart.nodeType !== 1)\r\n    clipStart = clipStart.nextSibling;\r\n  while (clipStart !== clipEnd && clipEnd.nodeType !== 1)\r\n    clipEnd = clipEnd.previousSibling;\r\n  if (clipStart.nodeType !== 1)\r\n    return []; // no top-level elements!  start === end and it's not an element\r\n\r\n  // resultsPlus includes matches all matches descended from contextNode,\r\n  // including those that aren't in the clip range.\r\n  var resultsPlus = DomUtils.findAll(contextNode, selector);\r\n\r\n  // Filter the list of nodes to remove nodes that occur before start\r\n  // or after end.\r\n  return _.reject(resultsPlus, function (n) {\r\n    return ! isElementInClipRange(n, clipStart, clipEnd);\r\n  });\r\n};\r\n\r\n// Like `findAllClipped` but finds one element (or returns null).\r\nDomUtils.findClipped = function (contextNode, selector, clipStart, clipEnd) {\r\n  var results = DomUtils.findAllClipped(\r\n    contextNode, selector, clipStart, clipEnd);\r\n  return (results.length ? results[0] : null);\r\n};\r\n\r\n// Executes `func` while ensuring that `element` has an ID.  If `element`\r\n// doesn't have an ID, it is assigned `magicId` temporarily.\r\n// Calls func with a selector of the form \"[id='...']\" as an argument.\r\nvar withElementId = function (element, magicId, func) {\r\n  var didSetId = false;\r\n  if (! element.getAttribute('id')) {\r\n    element.setAttribute('id', magicId);\r\n    didSetId = true;\r\n  }\r\n  try {\r\n    var escapedNodeId = element.getAttribute('id').replace(/'/g, \"\\\\$&\");\r\n    return func(\"[id='\" + escapedNodeId + \"']\");\r\n  } finally {\r\n    if (didSetId)\r\n      element.removeAttribute('id');\r\n  }\r\n};\r\n\r\nvar matchesSelectorMaybeClipped = function (element, contextNode, selector,\r\n                                           clipStart, clipEnd) {\r\n  var selecs = selector.split(',');\r\n  for(var i = 0, N = selecs.length; i < N; i++) {\r\n    var matches = withElementId(\r\n      element, \"DomUtils_matchesSelector_target\",\r\n      function (idSelector) {\r\n        var trimmedSelector = selector.match(/\\S.*?(?=\\s*$)/)[0];\r\n        // appending [id='foo'] to a selector with no whitespace ought to\r\n        // simply restrict the set of possible outputs regardless of the\r\n        // form of the selector.\r\n        var doctoredSelector = trimmedSelector + idSelector;\r\n        var result;\r\n        if (clipStart)\r\n          result = DomUtils.findClipped(contextNode, doctoredSelector,\r\n                                        clipStart, clipEnd);\r\n        else\r\n          result = DomUtils.find(contextNode, doctoredSelector);\r\n        return (result === element);\r\n      });\r\n\r\n    if (matches)\r\n      return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n// Check if `element` matches `selector`, scoped to `contextNode`.\r\nDomUtils.matchesSelector = function (element, contextNode, selector) {\r\n  return matchesSelectorMaybeClipped(element, contextNode, selector);\r\n};\r\n\r\n// Check if `element` matches `selector`, scoped to `contextNode`,\r\n// clipped to ordered siblings `clipStart`..`clipEnd`.\r\nDomUtils.matchesSelectorClipped = function (element, contextNode, selector,\r\n                                            clipStart, clipEnd) {\r\n  return matchesSelectorMaybeClipped(element, contextNode, selector,\r\n                                     clipStart, clipEnd);\r\n};\r\n\r\n// Returns 0 if the nodes are the same or either one contains the other;\r\n// otherwise, -1 if a comes before b, or else 1 if b comes before a in\r\n// document order.\r\n// Requires: `a` and `b` are element nodes in the same document tree.\r\nDomUtils.compareElementIndex = function (a, b) {\r\n  // See http://ejohn.org/blog/comparing-document-position/\r\n  if (a === b)\r\n    return 0;\r\n  if (a.compareDocumentPosition) {\r\n    var n = a.compareDocumentPosition(b);\r\n    return ((n & 0x18) ? 0 : ((n & 0x4) ? -1 : 1));\r\n  } else {\r\n    // Only old IE is known to not have compareDocumentPosition (though Safari\r\n    // originally lacked it).  Thankfully, IE gives us a way of comparing elements\r\n    // via the \"sourceIndex\" property.\r\n    if (a.contains(b) || b.contains(a))\r\n      return 0;\r\n    return (a.sourceIndex < b.sourceIndex ? -1 : 1);\r\n  }\r\n};\r\n\r\n// Wrap `frag` as necessary to prepare it for insertion in\r\n// `container`. For example, if `frag` has TR nodes at top level,\r\n// and `container` is a TABLE, then it's necessary to wrap `frag` in\r\n// a TBODY to avoid IE quirks.\r\n//\r\n// `frag` is a DocumentFragment and will be modified in\r\n// place. `container` is a DOM element.\r\nDomUtils.wrapFragmentForContainer = function (frag, container) {\r\n  if (container && container.nodeName === \"TABLE\" &&\r\n      _.any(frag.childNodes,\r\n            function (n) { return n.nodeName === \"TR\"; })) {\r\n    // Avoid putting a TR directly in a TABLE without an\r\n    // intervening TBODY, because it doesn't work in IE.  We do\r\n    // the same thing on all browsers for ease of testing\r\n    // and debugging.\r\n    var tbody = document.createElement(\"TBODY\");\r\n    tbody.appendChild(frag);\r\n    frag.appendChild(tbody);\r\n  }\r\n};\r\n\r\n// Return true if `node` is part of the global DOM document. Like\r\n// elementContains(document, node), except (1) it works for any node\r\n// (eg, text nodes), not just elements; (2) it works around browser\r\n// quirks that would otherwise come up when passing 'document' as\r\n// the first argument to elementContains.\r\n//\r\n// Returns true if node === document.\r\nDomUtils.isInDocument = function (node) {\r\n  // Deal with all cases where node is not an element\r\n  // node descending from the body first...\r\n  if (node === document)\r\n    return true;\r\n\r\n  if (node.nodeType !== 1 /* Element */)\r\n    node = node.parentNode;\r\n  if (! (node && node.nodeType === 1))\r\n    return false;\r\n  if (node === document.body)\r\n    return true;\r\n\r\n  return DomUtils.elementContains(document.body, node);\r\n};\r\n\r\n// Return an HTML string representation of the nodes from\r\n// firstNode to lastNode, which must be siblings.\r\n// The tags representing firstNode and lastNode are included,\r\n// but not their parent or outer siblings.\r\nDomUtils.rangeToHtml = function (firstNode, lastNode) {\r\n  var frag = document.createDocumentFragment();\r\n  for(var n = firstNode, after = lastNode.nextSibling;\r\n      n && n !== after;\r\n      n = n.nextSibling)\r\n    frag.appendChild(n.cloneNode(true)); // deep copy\r\n  return DomUtils.fragmentToHtml(frag);\r\n};\r\n\r\n// Return an HTML string representation of node, including its\r\n// own open and close tag.\r\nDomUtils.outerHtml = function (node) {\r\n  return DomUtils.rangeToHtml(node, node);\r\n};\r\n\r\n// Sets the value of an element, portably across browsers. There's a special\r\n// case for SELECT elements in IE.\r\nDomUtils.setElementValue = function (node, value) {\r\n  // Try to assign the value.\r\n  node.value = value;\r\n  if (node.value === value || node.nodeName !== 'SELECT')\r\n    return;\r\n\r\n  // IE (all versions) appears to only let you assign SELECT values which\r\n  // match valid OPTION values... and moreover, the OPTION value must be\r\n  // explicitly given as an attribute, not just as the text. So we hunt for\r\n  // the OPTION and select it.\r\n  var options = DomUtils.findAll(node, 'option');\r\n  for (var i = 0; i < options.length; ++i) {\r\n    if (DomUtils.getElementValue(options[i]) === value) {\r\n      options[i].selected = true;\r\n      return;\r\n    }\r\n  }\r\n};\r\n\r\n// Gets the value of an element, portably across browsers. There's a special\r\n// case for SELECT elements in IE.\r\nDomUtils.getElementValue = function (node) {\r\n  if (!quirks.selectValueMustBeFromAttribute)\r\n    return node.value;\r\n\r\n  if (node.nodeName === 'OPTION') {\r\n    // Inspired by jQuery.valHooks.option.get.\r\n    var val = node.attributes.value;\r\n    return !val || val.specified ? node.value : node.text;\r\n  } else if (node.nodeName === 'SELECT') {\r\n    if (node.selectedIndex < 0)\r\n      return null;\r\n    return DomUtils.getElementValue(node.options[node.selectedIndex]);\r\n  } else {\r\n    return node.value;\r\n  }\r\n};\r\n"]}