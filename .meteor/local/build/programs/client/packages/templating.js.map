)]}'
{"version":3,"file":"\\packages\\templating.js","sources":["templating/deftemplate.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,4B;;AAEA,+E;AACA,8E;AACA,kC;AACA,mC;AACA,kD;AACA,iC;;AAEA,4C;AACA,kC;AACA,8D;;AAEA,8C;AACA,8D;AACA,kC;AACA,2B;AACA,iC;AACA,8D;AACA,M;AACA,sB;AACA,0E;AACA,sD;;AAEA,gE;AACA,uD;AACA,0C;AACA,2C;;AAEA,sB;AACA,U;AACA,uB;AACA,iC;AACA,0F;AACA,qE;AACA,oD;AACA,a;AACA,Q;AACA,mB;AACA,gC;AACA,8C;AACA,O;AACA,M;AACA,I;;AAEA,yC;AACA,iC;AACA,sB;AACA,wC;AACA,gC;AACA,S;AACA,M;AACA,kC;AACA,sB;AACA,mE;AACA,gC;AACA,S;AACA,K;AACA,K;AACA,E;;AAEA,iD;AACA,oD;AACA,8B;;AAEA,mD;AACA,uD;AACA,yC;AACA,uB;AACA,iC;AACA,gC;AACA,iD;AACA,uC;AACA,Q;AACA,oC;AACA,gC;AACA,iD;AACA,0C;AACA,O;AACA,O;AACA,wB;AACA,uE;AACA,qE;AACA,kB;AACA,E;;AAEA,2C;AACA,oB;AACA,0E;AACA,mB;AACA,sD;AACA,+B;AACA,gB;AACA,oE;AACA,+C;AACA,0C;AACA,kC;AACA,O;AACA,I;AACA,oC;AACA,kB;AACA,wE;;AAEA,+B;AACA,+C;AACA,kC;AACA,S;AACA,Q;AACA,sC;AACA,I;AACA,iC;AACA,iB;AACA,sE;AACA,2B;AACA,gC;AACA,G;AACA,E;;AAEA,iD;AACA,mB;;AAEA,4B;AACA,kE;AACA,gE;;AAEA,qD;;AAEA,iC;AACA,4C;AACA,yC;;AAEA,gE;AACA,uC;AACA,0C;AACA,8B;AACA,uD;AACA,+B;AACA,sD;AACA,U;AACA,+B;AACA,uD;AACA,+B;AACA,wD;AACA,U;AACA,gC;AACA,iE;AACA,2B;AACA,+D;AACA,+C;AACA,S;AACA,8B;AACA,8C;AACA,oE;AACA,qC;AACA,iC;AACA,mE;AACA,yC;AACA,sB;AACA,a;AACA,W;;AAEA,uE;AACA,qE;AACA,uE;AACA,mD;AACA,+B;AACA,wD;AACA,iD;AACA,0E;AACA,sC;AACA,a;AACA,mE;AACA,iD;AACA,gD;AACA,uE;AACA,gB;AACA,e;AACA,a;AACA,6B;AACA,U;;AAEA,yD;AACA,oB;AACA,oD;AACA,8C;AACA,iE;AACA,mE;AACA,4C;AACA,wB;AACA,gE;AACA,oB;AACA,S;AACA,8C;AACA,kB;AACA,O;;AAEA,gB;AACA,I;;AAEA,gE;AACA,8D;AACA,gE;AACA,mC;AACA,wC;;;AAGA,a;AACA,uB;AACA,qE;AACA,+D;;AAEA,6B;AACA,oC;AACA,4B;;AAEA,uC;AACA,G;;AAEA,4C;AACA,iB;AACA,E","sourcesContent":["Template = {};\r\n\r\nvar registeredPartials = {};\r\n\r\n// If minimongo is available (it's a weak dependency) use its ID stringifier to\r\n// label branches (so that, eg, ObjectId and strings don't overlap). Otherwise\r\n// just use the identity function.\r\nvar idStringify = Package.minimongo\r\n  ? Package.minimongo.LocalCollection._idStringify\r\n  : function (id) { return id; };\r\n\r\n// XXX Handlebars hooking is janky and gross\r\nvar hookHandlebars = function () {\r\n  hookHandlebars = function(){}; // install the hook only once\r\n\r\n  var orig = Handlebars._default_helpers.each;\r\n  Handlebars._default_helpers.each = function (arg, options) {\r\n    var isArgValid = function () {\r\n      return !arg // falsey\r\n        || (arg instanceof Array)\r\n        || (arg instanceof Object && 'observeChanges' in arg);\r\n    };\r\n    if (!isArgValid())\r\n      throw new Error(\"{{#each}} only accepts arrays, cursors, or falsey \"\r\n                      + \"values. You passed: \" + arg);\r\n\r\n    // if arg isn't an observable (like LocalCollection.Cursor),\r\n    // don't use this reactive implementation of #each.\r\n    if (!(arg && 'observeChanges' in arg))\r\n      return orig.call(this, arg, options);\r\n\r\n    return Spark.list(\r\n      arg,\r\n      function (item) {\r\n        return Spark.labelBranch(\r\n          (item && item._id && idStringify(item._id)) || Spark.UNIQUE_LABEL, function () {\r\n            var html = Spark.isolate(_.bind(options.fn, null, item));\r\n            return Spark.setDataContext(item, html);\r\n          });\r\n      },\r\n      function () {\r\n        return options.inverse ?\r\n          Spark.isolate(options.inverse) : '';\r\n      }\r\n    );\r\n  };\r\n\r\n  _.extend(Handlebars._default_helpers, {\r\n    isolate: function (options) {\r\n      var data = this;\r\n      return Spark.isolate(function () {\r\n        return options.fn(data);\r\n      });\r\n    },\r\n    constant: function (options) {\r\n      var data = this;\r\n      return Spark.createLandmark({ constant: true }, function () {\r\n        return options.fn(data);\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\n// map from landmark id, to the 'this' object for\r\n// created/rendered/destroyed callbacks on templates\r\nvar templateInstanceData = {};\r\n\r\nvar templateObjFromLandmark = function (landmark) {\r\n  var template = templateInstanceData[landmark.id] || (\r\n    templateInstanceData[landmark.id] = {\r\n      // set these once\r\n      find: function (selector) {\r\n        if (! landmark.hasDom())\r\n          throw new Error(\"Template not in DOM\");\r\n        return landmark.find(selector);\r\n      },\r\n      findAll: function (selector) {\r\n        if (! landmark.hasDom())\r\n          throw new Error(\"Template not in DOM\");\r\n        return landmark.findAll(selector);\r\n      }\r\n    });\r\n  // set these each time\r\n  template.firstNode = landmark.hasDom() ? landmark.firstNode() : null;\r\n  template.lastNode = landmark.hasDom() ? landmark.lastNode() : null;\r\n  return template;\r\n};\r\n\r\n// XXX forms hooks into this to add \"bind\"?\r\nvar templateBase = {\r\n  // methods store data here (event map, etc.).  initialized per template.\r\n  _tmpl_data: null,\r\n  // these functions must be generic (i.e. use `this`)\r\n  events: function (eventMap) {\r\n    var events =\r\n          (this._tmpl_data.events = (this._tmpl_data.events || {}));\r\n    _.each(eventMap, function(callback, spec) {\r\n      events[spec] = (events[spec] || []);\r\n      events[spec].push(callback);\r\n    });\r\n  },\r\n  preserve: function (preserveMap) {\r\n    var preserve =\r\n          (this._tmpl_data.preserve = (this._tmpl_data.preserve || {}));\r\n\r\n    if (_.isArray(preserveMap))\r\n      _.each(preserveMap, function (selector) {\r\n        preserve[selector] = true;\r\n      });\r\n    else\r\n      _.extend(preserve, preserveMap);\r\n  },\r\n  helpers: function (helperMap) {\r\n    var helpers =\r\n          (this._tmpl_data.helpers = (this._tmpl_data.helpers || {}));\r\n    for(var h in helperMap)\r\n      helpers[h] = helperMap[h];\r\n  }\r\n};\r\n\r\nTemplate.__define__ = function (name, raw_func) {\r\n  hookHandlebars();\r\n\r\n  if (name === '__define__')\r\n    throw new Error(\"Sorry, '__define__' is a special name and \" +\r\n                    \"cannot be used as the name of a template\");\r\n\r\n  // Define the function assigned to Template.<name>.\r\n\r\n  var partial = function (data) {\r\n    var tmpl = name && Template[name] || {};\r\n    var tmplData = tmpl._tmpl_data || {};\r\n\r\n    var html = Spark.labelBranch(\"Template.\"+name, function () {\r\n      var html = Spark.createLandmark({\r\n        preserve: tmplData.preserve || {},\r\n        created: function () {\r\n          var template = templateObjFromLandmark(this);\r\n          template.data = data;\r\n          tmpl.created && tmpl.created.call(template);\r\n        },\r\n        rendered: function () {\r\n          var template = templateObjFromLandmark(this);\r\n          template.data = data;\r\n          tmpl.rendered && tmpl.rendered.call(template);\r\n        },\r\n        destroyed: function () {\r\n          // template.data is already set from previous callbacks\r\n          tmpl.destroyed &&\r\n            tmpl.destroyed.call(templateObjFromLandmark(this));\r\n          delete templateInstanceData[this.id];\r\n        }\r\n      }, function (landmark) {\r\n        var html = Spark.isolate(function () {\r\n          // XXX Forms needs to run a hook before and after raw_func\r\n          // (and receive 'landmark')\r\n          return raw_func(data, {\r\n            helpers: _.extend({}, partial, tmplData.helpers || {}),\r\n            partials: registeredPartials,\r\n            name: name\r\n          });\r\n        });\r\n\r\n        // take an event map with `function (event, template)` handlers\r\n        // and produce one with `function (event, landmark)` handlers\r\n        // for Spark, by inserting logic to create the template object.\r\n        var wrapEventMap = function (oldEventMap) {\r\n          var newEventMap = {};\r\n          _.each(oldEventMap, function (handlers, key) {\r\n            if ('function' === typeof handlers) {\r\n              //Template.foo.events = ... way will give a fn, not an array\r\n              handlers = [ handlers ];\r\n            }\r\n            newEventMap[key] = _.map(handlers, function (handler) {\r\n              return function (event, landmark) {\r\n                return handler.call(this, event,\r\n                                    templateObjFromLandmark(landmark));\r\n              };\r\n            });\r\n          });\r\n          return newEventMap;\r\n        };\r\n\r\n        // support old Template.foo.events = {...} format\r\n        var events =\r\n              (tmpl.events !== templateBase.events ?\r\n               tmpl.events : tmplData.events);\r\n        // events need to be inside the landmark, not outside, so\r\n        // that when an event fires, you can retrieve the enclosing\r\n        // landmark to get the template data\r\n        if (tmpl.events)\r\n          html = Spark.attachEvents(wrapEventMap(events), html);\r\n        return html;\r\n      });\r\n      html = Spark.setDataContext(data, html);\r\n      return html;\r\n    });\r\n\r\n    return html;\r\n  };\r\n\r\n  // XXX hack.. copy all of Handlebars' built in helpers over to\r\n  // the partial. it would be better to hook helperMissing (or\r\n  // something like that?) so that Template.foo is searched only\r\n  // if it's not a built-in helper.\r\n  _.extend(partial, Handlebars.helpers);\r\n\r\n\r\n  if (name) {\r\n    if (Template[name])\r\n      throw new Error(\"There are multiple templates named '\" + name +\r\n                      \"'. Each template needs a unique name.\");\r\n\r\n    Template[name] = partial;\r\n    _.extend(partial, templateBase);\r\n    partial._tmpl_data = {};\r\n\r\n    registeredPartials[name] = partial;\r\n  }\r\n\r\n  // useful for unnamed templates, like body\r\n  return partial;\r\n};\r\n"]}