)]}'
{"version":3,"file":"\\packages\\spark.js","sources":["spark/spark.js","spark/patch.js","spark/convenience.js","spark/utils.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,oE;AACA,+D;;AAEA,4D;AACA,sD;;AAEA,oE;AACA,6C;;AAEA,qE;AACA,gC;;AAEA,iE;AACA,sE;AACA,0B;;AAEA,gE;;AAEA,mE;AACA,qE;AACA,sD;;AAEA,uE;AACA,gE;AACA,qE;AACA,gC;;AAEA,W;AACA,e;;AAEA,oC;AACA,qB;AACA,U;AACA,sB;AACA,qB;AACA,M;AACA,mC;AACA,6B;AACA,kB;AACA,4B;AACA,qC;AACA,K;AACA,I;AACA,K;;AAEA,8B;AACA,oB;;AAEA,oE;AACA,kE;AACA,oE;AACA,iE;AACA,+B;AACA,iB;;AAEA,qD;AACA,iC;AACA,6B;AACA,mC;AACA,iC;AACA,+B;AACA,+B;AACA,qC;AACA,6B;AACA,kC;AACA,oE;;AAEA,uE;AACA,8B;AACA,mD;AACA,4B;AACA,E;;AAEA,iD;AACA,yB;AACA,uD;AACA,oC;AACA,E;;;AAGA,oD;AACA,oD;AACA,oB;AACA,e;AACA,E;;AAEA,6C;AACA,6C;AACA,sC;AACA,+B;;AAEA,e;AACA,E;;AAEA,+C;AACA,M;AACA,+B;AACA,yC;;AAEA,e;AACA,E;;AAEA,4C;AACA,uE;AACA,4D;AACA,uC;AACA,oB;AACA,sB;AACA,E;;AAEA,6B;AACA,sE;AACA,qE;AACA,qE;AACA,4C;AACA,oE;AACA,2C;AACA,sC;AACA,kC;AACA,0B;AACA,wB;AACA,0C;AACA,E;;AAEA,wB;AACA,sE;AACA,sD;AACA,wB;;AAEA,iE;AACA,gE;AACA,8D;AACA,+D;AACA,4C;AACA,6C;AACA,gE;AACA,uC;AACA,yB;;AAEA,4D;AACA,qE;AACA,4C;;AAEA,uD;AACA,2B;;AAEA,yD;AACA,uC;AACA,E;;AAEA,8B;AACA,sE;AACA,qE;AACA,wD;AACA,kE;AACA,qE;AACA,+C;AACA,yC;AACA,qC;AACA,yB;AACA,+B;AACA,kB;AACA,mC;AACA,Q;AACA,K;AACA,mE;AACA,wE;AACA,yE;AACA,8D;AACA,0E;AACA,mE;AACA,2C;AACA,8C;AACA,kD;AACA,kC;AACA,mE;AACA,iC;AACA,4D;AACA,mB;AACA,e;AACA,O;AACA,8C;AACA,kB;AACA,M;;AAEA,qD;AACA,I;;AAEA,8D;AACA,gE;AACA,uD;AACA,8D;AACA,gE;AACA,yB;AACA,8B;AACA,oC;AACA,Y;AACA,mC;AACA,0C;AACA,8B;AACA,gD;AACA,Q;AACA,6B;AACA,oB;AACA,Q;AACA,6B;AACA,0C;AACA,mB;AACA,Q;AACA,iE;AACA,4D;AACA,oD;AACA,+D;AACA,6B;AACA,6B;AACA,sC;AACA,wC;AACA,iB;AACA,gC;AACA,O;AACA,M;AACA,I;;AAEA,qE;AACA,oC;AACA,oC;AACA,oB;;AAEA,yD;AACA,oE;;AAEA,sB;AACA,kD;AACA,mC;AACA,iB;AACA,iC;AACA,0C;AACA,2C;AACA,+B;AACA,+B;AACA,4E;AACA,8C;AACA,gE;AACA,4B;AACA,0D;AACA,kE;AACA,+C;AACA,W;AACA,iD;AACA,+B;AACA,S;AACA,iB;AACA,O;AACA,M;;AAEA,2B;AACA,qB;AACA,Y;;AAEA,6C;AACA,wB;AACA,c;AACA,wC;AACA,8B;AACA,wB;AACA,gD;AACA,qC;AACA,wE;AACA,2C;AACA,+D;AACA,oC;AACA,2D;AACA,0B;AACA,yB;AACA,6B;AACA,c;AACA,sC;AACA,6B;AACA,uE;AACA,uE;AACA,gC;AACA,4E;AACA,mD;AACA,8B;AACA,4D;AACA,wD;AACA,qD;AACA,+B;AACA,uE;AACA,kE;AACA,mE;AACA,0E;AACA,uE;AACA,iD;AACA,qB;AACA,gB;AACA,S;AACA,4B;AACA,sE;AACA,O;AACA,K;;AAEA,oD;AACA,6B;;AAEA,uD;AACA,yB;AACA,4E;AACA,yB;AACA,O;AACA,0B;;AAEA,8E;AACA,2E;AACA,6D;AACA,M;AACA,8E;AACA,8E;AACA,0B;AACA,M;AACA,mE;AACA,gF;AACA,0E;AACA,O;AACA,4E;AACA,4B;AACA,4D;AACA,O;;AAEA,e;AACA,G;;AAEA,G;;AAEA,2D;AACA,yD;AACA,wD;AACA,yD;AACA,iC;AACA,qC;AACA,yC;AACA,oC;AACA,kB;AACA,wB;AACA,wB;AACA,+B;AACA,I;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,mE;AACA,oE;AACA,6B;AACA,E;AACA,yE;AACA,iD;AACA,E;AACA,qE;AACA,sE;AACA,uD;AACA,6D;AACA,+C;AACA,wB;AACA,wC;AACA,qB;AACA,I;;AAEA,+B;AACA,kB;AACA,a;;AAEA,4D;AACA,iE;AACA,oE;AACA,mE;AACA,qE;AACA,sE;AACA,iE;AACA,kE;AACA,mC;AACA,2C;AACA,6B;AACA,+B;AACA,6B;AACA,oE;AACA,sD;AACA,iE;AACA,6D;AACA,c;AACA,6B;AACA,e;AACA,O;AACA,K;;AAEA,6D;AACA,kD;AACA,qD;AACA,8C;AACA,4D;AACA,O;;AAEA,iE;AACA,sB;AACA,M;AACA,oE;AACA,qE;AACA,kB;AACA,M;AACA,sE;AACA,6B;AACA,6B;AACA,gE;AACA,wC;;AAEA,gE;AACA,iE;AACA,kE;AACA,wC;AACA,wE;AACA,4B;AACA,K;AACA,E;;AAEA,oC;AACA,8B;AACA,4C;AACA,c;AACA,E;;;AAGA,gE;AACA,qE;AACA,e;AACA,E;AACA,oB;AACA,yC;AACA,E;AACA,iC;AACA,qD;AACA,4B;AACA,E;AACA,qE;AACA,oE;AACA,uE;AACA,2E;AACA,0C;AACA,kE;AACA,gC;AACA,E;;AAEA,4C;AACA,0E;AACA,wE;AACA,+D;AACA,oE;AACA,oB;AACA,kE;AACA,+D;AACA,I;;AAEA,0C;AACA,oB;AACA,mC;AACA,qB;AACA,4D;AACA,kB;AACA,O;AACA,I;;AAEA,4D;AACA,oB;AACA,0D;;AAEA,wF;AACA,uD;AACA,0C;AACA,wE;;AAEA,kC;AACA,mC;AACA,gC;AACA,S;AACA,M;;AAEA,8D;AACA,wC;AACA,iC;AACA,8D;AACA,6C;AACA,0B;AACA,8D;AACA,+B;AACA,uD;AACA,a;AACA,S;AACA,O;;AAEA,mE;AACA,2D;AACA,M;AACA,8E;AACA,yE;AACA,8E;AACA,6E;AACA,wC;AACA,kF;AACA,wD;AACA,wD;AACA,8D;AACA,6E;AACA,wD;AACA,6C;;AAEA,wC;AACA,8D;AACA,kG;AACA,6D;AACA,sB;AACA,qE;AACA,0D;AACA,W;AACA,W;AACA,S;AACA,O;;AAEA,iE;AACA,uD;AACA,+C;AACA,2B;AACA,6C;AACA,wB;;AAEA,yB;AACA,G;AACA,G;;;AAGA,gB;AACA,iC;AACA,mB;AACA,qD;AACA,0B;AACA,2B;AACA,E;;AAEA,mE;AACA,sE;AACA,E;AACA,kD;AACA,4D;AACA,mB;AACA,I;AACA,uE;AACA,sE;AACA,sE;AACA,yD;AACA,gE;AACA,c;AACA,oC;AACA,4C;AACA,W;;AAEA,gC;;AAEA,oE;AACA,iE;AACA,oE;AACA,sE;AACA,+D;AACA,sD;AACA,yC;;AAEA,uC;AACA,wC;AACA,oB;AACA,mC;AACA,Y;AACA,2B;AACA,6D;AACA,kC;AACA,O;AACA,O;AACA,I;;AAEA,+D;AACA,gE;AACA,wC;AACA,K;;AAEA,gF;AACA,4E;AACA,8E;AACA,+E;AACA,0E;AACA,uC;AACA,+C;AACA,yC;AACA,kC;AACA,4C;AACA,K;;AAEA,4C;;AAEA,iE;;AAEA,2C;;AAEA,8D;AACA,sB;AACA,uB;AACA,wB;AACA,gD;AACA,gC;AACA,mC;AACA,mE;;AAEA,0C;AACA,uD;AACA,O;AACA,O;;AAEA,mE;AACA,mB;AACA,mB;AACA,sC;AACA,sC;AACA,iE;AACA,8D;AACA,0B;AACA,sE;AACA,wC;AACA,Y;;AAEA,gD;AACA,wE;AACA,G;;AAEA,gD;;AAEA,qE;AACA,gE;;AAEA,sB;;AAEA,mB;;AAEA,iC;AACA,8B;AACA,yC;AACA,6D;AACA,6D;AACA,8B;AACA,iC;AACA,0D;AACA,qD;AACA,O;AACA,K;;AAEA,gE;AACA,4D;AACA,uD;AACA,oE;AACA,iE;AACA,mB;AACA,6C;AACA,K;AACA,E;;AAEA,qE;AACA,sE;AACA,wD;AACA,E;AACA,wC;AACA,2E;AACA,8D;AACA,iC;AACA,iD;AACA,4B;AACA,iB;AACA,e;AACA,G;AACA,+C;AACA,2C;AACA,kD;AACA,K;AACA,wC;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,6E;AACA,4B;AACA,kD;AACA,G;;AAEA,wC;AACA,qD;AACA,6B;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,6B;AACA,+B;AACA,yB;AACA,qE;AACA,mE;AACA,sE;AACA,yD;AACA,gE;AACA,qE;AACA,sE;AACA,uC;;AAEA,2B;AACA,4B;AACA,e;;AAEA,sB;AACA,mD;AACA,sD;AACA,oB;AACA,0B;AACA,yD;AACA,O;AACA,mC;AACA,yB;AACA,S;AACA,0B;;AAEA,2B;AACA,E;;AAEA,wE;AACA,+B;;AAEA,6D;AACA,6E;AACA,qD;AACA,4B;AACA,8C;AACA,0C;AACA,gC;AACA,K;AACA,qC;AACA,sE;AACA,uC;AACA,sC;AACA,6B;AACA,e;;AAEA,+B;AACA,qC;;AAEA,gD;AACA,4C;AACA,wE;AACA,S;AACA,O;AACA,K;;AAEA,sC;;AAEA,0C;AACA,qC;AACA,oC;AACA,mD;AACA,2B;AACA,4B;AACA,sC;AACA,O;AACA,I;;AAEA,4B;AACA,6B;AACA,2B;AACA,8B;AACA,O;AACA,O;;AAEA,wB;;AAEA,4B;AACA,+C;AACA,kB;AACA,e;;AAEA,uC;AACA,4B;AACA,S;AACA,6B;;AAEA,oC;AACA,yB;AACA,Q;;AAEA,wC;AACA,oD;;AAEA,mD;AACA,iE;AACA,mB;;AAEA,oC;AACA,0C;AACA,0C;;AAEA,yB;AACA,kD;AACA,mE;AACA,qD;AACA,uB;AACA,a;AACA,kB;AACA,0D;AACA,qD;AACA,uB;AACA,W;;AAEA,+C;AACA,0E;AACA,6B;AACA,6D;AACA,mE;;AAEA,qE;AACA,mE;AACA,wE;AACA,yE;AACA,sE;;AAEA,sE;AACA,8C;AACA,sC;AACA,6C;AACA,mC;AACA,W;AACA,S;AACA,Q;AACA,O;;AAEA,c;AACA,G;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,qC;AACA,uC;AACA,gB;AACA,sB;;AAEA,Y;AACA,sB;AACA,c;AACA,kC;AACA,mB;AACA,kC;AACA,uC;AACA,sB;AACA,oB;AACA,qD;AACA,0B;AACA,kB;AACA,sB;AACA,0C;AACA,qE;AACA,iE;AACA,8B;AACA,4B;AACA,c;AACA,W;AACA,W;AACA,uB;AACA,Y;AACA,2C;AACA,K;AACA,K;;AAEA,iB;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,6D;AACA,iD;AACA,8C;AACA,4B;AACA,sB;AACA,Q;AACA,uB;AACA,K;AACA,E;;;AAGA,gF;AACA,wE;AACA,qB;AACA,uC;AACA,+B;AACA,kD;AACA,iC;;AAEA,oD;AACA,oD;;AAEA,oE;AACA,0B;AACA,qB;AACA,6B;AACA,gF;AACA,2C;AACA,oD;AACA,M;AACA,K;;AAEA,4C;;AAEA,8C;AACA,uB;AACA,8C;AACA,kC;AACA,mB;AACA,4C;AACA,0C;AACA,K;AACA,K;AACA,wD;;AAEA,6B;AACA,uC;AACA,gC;AACA,6C;AACA,qC;;AAEA,kE;AACA,wE;AACA,a;AACA,I;AACA,qE;AACA,wE;AACA,uE;AACA,4C;AACA,uC;AACA,qD;AACA,qD;AACA,e;AACA,I;;AAEA,iE;AACA,qE;AACA,mB;AACA,gB;AACA,iB;AACA,uB;AACA,sB;AACA,Q;AACA,qC;AACA,8B;AACA,4C;AACA,+B;AACA,4B;AACA,kC;AACA,a;AACA,O;AACA,G;AACA,sB;AACA,6B;AACA,kB;AACA,mB;AACA,I;AACA,gE;AACA,kB;AACA,qE;AACA,e;AACA,gB;AACA,Y;AACA,yB;AACA,oC;AACA,K;AACA,K;;AAEA,qE;AACA,+B;AACA,iB;AACA,c;;AAEA,0E;AACA,sB;AACA,wE;AACA,sE;AACA,qE;AACA,0E;AACA,2C;AACA,0B;AACA,gE;AACA,wC;AACA,I;;AAEA,4B;AACA,iC;AACA,oB;AACA,0B;AACA,O;AACA,I;;AAEA,8B;AACA,uB;AACA,gD;AACA,yB;AACA,sC;AACA,qB;AACA,6E;AACA,4E;AACA,0D;;AAEA,+B;AACA,2D;AACA,qC;AACA,2D;AACA,gB;AACA,4D;AACA,S;AACA,qE;AACA,S;AACA,M;;AAEA,4B;AACA,yB;AACA,mD;AACA,4C;AACA,8E;AACA,2D;AACA,c;AACA,+D;;AAEA,4B;;AAEA,gC;AACA,S;AACA,M;;AAEA,wC;AACA,yB;AACA,wD;AACA,8B;AACA,2D;AACA,S;AACA,c;AACA,4D;AACA,S;AACA,wC;AACA,gC;AACA,S;AACA,M;;AAEA,oC;AACA,yB;AACA,mC;AACA,iB;AACA,2D;AACA,sC;AACA,0C;AACA,6E;AACA,S;AACA,K;AACA,K;;AAEA,c;AACA,E;;AAEA,gF;AACA,gF;AACA,gF;;AAEA,uB;;AAEA,8B;AACA,6B;AACA,sD;AACA,E;;AAEA,oC;AACA,0B;AACA,mC;AACA,I;AACA,yB;AACA,kC;AACA,I;AACA,6B;AACA,wB;AACA,4D;AACA,6D;AACA,I;AACA,gC;AACA,wB;AACA,+D;AACA,gE;AACA,I;AACA,uB;AACA,0B;AACA,G;AACA,G;;AAEA,sC;;AAEA,0B;AACA,qE;AACA,2B;AACA,E;AACA,gD;AACA,uC;AACA,mC;AACA,sB;;AAEA,mC;AACA,wB;;AAEA,0C;AACA,wB;AACA,4D;AACA,oC;;AAEA,iB;AACA,uE;AACA,uE;AACA,6B;AACA,gB;;AAEA,2B;AACA,8C;;AAEA,kE;AACA,gE;AACA,qE;AACA,qE;AACA,oE;AACA,mE;AACA,mE;AACA,kE;AACA,qE;AACA,mE;AACA,qE;AACA,Y;AACA,E;;AAEA,qD;AACA,uC;AACA,mB;AACA,wD;AACA,sC;AACA,sD;AACA,kC;AACA,0D;AACA,gB;AACA,G;;AAEA,2B;AACA,oB;AACA,kC;AACA,kD;AACA,gC;AACA,O;AACA,M;AACA,sC;AACA,gC;AACA,iD;AACA,wD;;AAEA,0C;AACA,gD;AACA,e;AACA,4B;AACA,uC;AACA,qE;AACA,+E;AACA,gE;AACA,U;AACA,kC;AACA,0B;AACA,uE;AACA,oC;AACA,uC;AACA,S;AACA,K;AACA,G;AACA,4B;;AAEA,gC;AACA,2B;AACA,iD;AACA,oB;AACA,8B;AACA,8D;AACA,e;AACA,O;;AAEA,uB;AACA,2B;AACA,sC;AACA,qD;AACA,uD;AACA,2B;AACA,+B;AACA,kC;AACA,wC;AACA,+C;AACA,W;AACA,S;AACA,S;;AAEA,8B;AACA,0C;AACA,mE;AACA,qE;AACA,sE;AACA,8D;AACA,oE;AACA,6D;AACA,mE;AACA,Q;AACA,qE;AACA,0D;AACA,kE;AACA,qE;AACA,qE;AACA,2D;AACA,sB;AACA,O;AACA,E;;AAEA,kD;AACA,yD;AACA,uC;AACA,E;;;;;;;;;;;;;;;;;;;AC5tCA,0E;AACA,2B;;AAEA,iC;AACA,uC;AACA,I;;AAEA,4B;AACA,+C;;;AAGA,0D;AACA,gE;AACA,yB;AACA,4B;AACA,4C;AACA,wC;AACA,K;AACA,I;;AAEA,4E;AACA,4B;AACA,8D;AACA,6B;AACA,0D;AACA,gE;;AAEA,0B;;AAEA,mD;AACA,wD;AACA,2E;AACA,kE;AACA,oD;AACA,mD;AACA,wD;AACA,mE;AACA,8C;AACA,yC;AACA,+C;AACA,O;;AAEA,e;AACA,sE;AACA,2B;AACA,gE;AACA,qC;AACA,mD;AACA,sE;AACA,8C;AACA,2E;AACA,6E;AACA,2E;AACA,0D;AACA,sC;AACA,2D;AACA,oD;AACA,W;AACA,0C;AACA,kD;AACA,8B;AACA,+B;AACA,mD;AACA,6E;AACA,2E;AACA,gF;AACA,0E;AACA,qC;AACA,2D;AACA,e;AACA,a;AACA,2D;AACA,W;AACA,S;AACA,O;AACA,K;AACA,gB;AACA,K;;AAEA,mB;;AAEA,iB;AACA,E;;;AAGA,uE;AACA,oE;AACA,E;AACA,0E;AACA,kE;AACA,kE;AACA,uE;AACA,iD;AACA,E;AACA,oE;AACA,Y;AACA,E;AACA,uE;AACA,sE;AACA,uE;AACA,mE;AACA,2E;AACA,0E;AACA,kB;AACA,E;AACA,e;AACA,+D;AACA,6B;AACA,6B;;AAEA,6B;AACA,2B;;AAEA,8B;AACA,8B;AACA,E;;;AAGA,kE;AACA,mE;AACA,mE;AACA,iE;AACA,uE;AACA,oE;AACA,qE;AACA,iE;AACA,kD;AACA,E;AACA,iE;AACA,8D;AACA,+D;AACA,iE;AACA,oD;AACA,E;AACA,+D;AACA,uE;AACA,oE;AACA,oE;AACA,qE;AACA,kE;AACA,mC;AACA,E;AACA,8D;AACA,mE;AACA,iE;AACA,gE;AACA,2D;AACA,6D;AACA,gE;AACA,8D;AACA,iE;AACA,oE;AACA,c;AACA,E;AACA,+D;AACA,mE;AACA,kE;AACA,yD;AACA,E;AACA,8D;AACA,kE;AACA,iC;AACA,mC;AACA,gD;;AAEA,2D;AACA,yC;AACA,yC;AACA,8C;AACA,oB;AACA,oB;;AAEA,2B;AACA,6C;AACA,G;;AAEA,+B;AACA,wB;;AAEA,mB;AACA,oD;AACA,uE;AACA,kE;AACA,iB;AACA,uD;AACA,8E;AACA,wD;AACA,yD;AACA,+C;AACA,+D;AACA,2C;AACA,2C;AACA,K;;AAEA,qE;AACA,uC;AACA,uC;;AAEA,yD;AACA,yD;AACA,gE;AACA,0D;AACA,+D;AACA,iE;AACA,gE;AACA,kE;AACA,2D;AACA,2D;AACA,+D;AACA,gB;AACA,sB;AACA,sD;AACA,wD;AACA,sE;AACA,mB;AACA,K;AACA,G;;AAEA,kB;AACA,4D;AACA,uD;AACA,U;AACA,sE;AACA,wB;AACA,wC;AACA,qB;AACA,K;;AAEA,gE;AACA,2B;AACA,+C;AACA,mE;AACA,6C;AACA,qE;AACA,0D;AACA,oC;AACA,8C;AACA,K;AACA,qE;AACA,iE;AACA,K;;AAEA,yB;AACA,6D;AACA,kB;AACA,yC;AACA,6C;AACA,4C;AACA,yB;AACA,iC;AACA,O;;AAEA,wB;;AAEA,8D;AACA,+B;AACA,2E;AACA,+D;AACA,c;AACA,c;AACA,iD;AACA,kD;AACA,6B;AACA,6B;AACA,O;AACA,K;AACA,G;;AAEA,iC;AACA,iC;;AAEA,c;AACA,E;;AAEA,sE;AACA,uC;AACA,uD;AACA,qC;AACA,qC;;AAEA,2D;AACA,iB;;AAEA,2D;AACA,iB;;AAEA,6B;AACA,6B;;AAEA,c;AACA,E;;AAEA,+C;AACA,E;AACA,4D;AACA,kB;AACA,uC;AACA,gC;AACA,E;;AAEA,0E;AACA,6E;AACA,0E;AACA,E;AACA,8E;AACA,gF;AACA,2C;AACA,uE;AACA,C;AACA,qE;AACA,qE;;AAEA,8C;AACA,qC;AACA,4C;AACA,yC;AACA,G;AACA,qC;AACA,4C;AACA,yC;AACA,G;;;AAGA,wB;AACA,Q;AACA,uE;AACA,6B;AACA,6B;AACA,G;;AAEA,qB;AACA,Q;AACA,uE;AACA,6B;AACA,gD;AACA,G;AACA,E;;AAEA,sD;AACA,E;AACA,mE;AACA,0E;AACA,6D;AACA,kE;AACA,+D;AACA,E;AACA,gE;AACA,wE;AACA,8C;AACA,gC;AACA,gC;;AAEA,2D;AACA,uB;AACA,uD;;AAEA,gC;;AAEA,wB;AACA,2B;;AAEA,sB;AACA,0B;AACA,iC;AACA,uD;AACA,qC;;AAEA,4E;AACA,gF;AACA,wC;AACA,6C;AACA,qE;AACA,iD;AACA,qE;AACA,iD;AACA,6E;AACA,8E;AACA,mE;AACA,mD;AACA,iD;AACA,sD;AACA,yC;AACA,c;AACA,0C;AACA,2D;AACA,O;AACA,K;AACA,G;;AAEA,2C;AACA,2B;AACA,wD;AACA,yD;AACA,wD;AACA,sD;AACA,sB;AACA,yB;AACA,e;AACA,yB;AACA,yD;AACA,4D;AACA,yB;AACA,yB;AACA,e;AACA,uD;AACA,uD;AACA,qC;AACA,yC;AACA,e;AACA,8D;AACA,0D;AACA,wD;AACA,gD;AACA,mC;AACA,e;AACA,+E;AACA,yB;AACA,yB;AACA,e;AACA,0D;AACA,uB;AACA,e;;AAEA,sE;AACA,gE;AACA,wE;AACA,0E;AACA,kD;AACA,M;AACA,0E;AACA,yD;AACA,M;AACA,qE;AACA,uE;AACA,2C;AACA,oC;AACA,0B;AACA,+C;AACA,+B;AACA,2E;AACA,kC;AACA,G;;AAEA,kC;;AAEA,4B;AACA,oB;AACA,M;AACA,kD;AACA,qD;AACA,2D;AACA,4D;AACA,8D;;AAEA,sD;AACA,qD;AACA,uD;;AAEA,6B;AACA,mB;AACA,mD;;AAEA,iB;AACA,0B;;AAEA,U;AACA,wB;;AAEA,+C;AACA,kC;AACA,2B;AACA,2C;AACA,uC;AACA,8B;AACA,6D;AACA,wC;AACA,oC;AACA,sC;AACA,gD;AACA,sC;AACA,wC;AACA,sC;AACA,yD;AACA,4B;AACA,oC;AACA,qD;AACA,kC;AACA,8B;AACA,gB;AACA,e;AACA,0C;AACA,uB;AACA,4E;AACA,W;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,+C;AACA,0C;AACA,kB;AACA,+C;AACA,I;AACA,4D;AACA,4D;;AAEA,qC;AACA,sD;;AAEA,kC;AACA,4E;AACA,gF;AACA,6C;AACA,0B;AACA,sC;AACA,0B;AACA,6C;AACA,6E;AACA,4D;AACA,mD;AACA,G;;AAEA,+E;AACA,+E;AACA,sD;AACA,2E;AACA,6E;AACA,6B;AACA,I;AACA,sD;AACA,0C;AACA,I;AACA,8E;AACA,4E;AACA,2E;AACA,yE;AACA,qE;AACA,wC;AACA,I;AACA,0E;AACA,6E;AACA,yE;AACA,gF;AACA,wE;AACA,8D;AACA,yE;AACA,+E;AACA,+E;AACA,yB;AACA,qD;AACA,8D;AACA,4E;AACA,+E;AACA,iE;AACA,G;;AAEA,qC;AACA,8B;AACA,gF;AACA,c;AACA,qC;AACA,iC;;AAEA,uD;AACA,sC;AACA,qB;AACA,6C;AACA,Q;AACA,qC;AACA,G;AACA,E;;AAEA,4B;;;;;;;;;;;;;;;;;;;AC7jBA,qC;AACA,mC;AACA,yB;AACA,8D;AACA,yE;AACA,gC;AACA,S;AACA,K;AACA,E;;AAEA,2D;AACA,mC;AACA,+C;AACA,0D;AACA,mD;AACA,2D;AACA,S;AACA,oB;AACA,qD;AACA,O;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;ACrBA,wC;AACA,mB;;AAEA,0C;AACA,+B;AACA,yC;AACA,wC;AACA,qC;AACA,kD;AACA,wD;AACA,mC;AACA,oD;AACA,mD;AACA,iC;AACA,mC;AACA,0D;AACA,kB;AACA,sC;;AAEA,wD;AACA,qB;AACA,4B;AACA,4D;AACA,yB;AACA,mB;AACA,2C;AACA,gB;AACA,4C;AACA,uD;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,e;AACA,E","sourcesContent":["// XXX adjust Spark API so that the modules (eg, list, events) could\r\n// have been written by third parties on top of the public API?\r\n\r\n// XXX rename isolate to reflect that it is the only root of\r\n// deps-based reactivity ('track'? 'compute'? 'sync'?)\r\n\r\n// XXX specify flush order someday (context dependencies? is this in\r\n// the domain of spark -- overdraw concerns?)\r\n\r\n// XXX if not on IE6-8, don't do the extra work (traversals for event\r\n// setup) those browsers require\r\n\r\n// XXX flag errors if you have two landmarks with the same branch\r\n// path, or if you have multiple preserve nodes in a landmark with the\r\n// same selector and label\r\n\r\n// XXX should functions with an htmlFunc use try/finally inside?\r\n\r\n// XXX test that non-Spark.render case works for each function (eg,\r\n// list() returns the expected HTML, Spark.createLandmark creates and\r\n// then destroys a landmark -- may already be tested?)\r\n\r\n// XXX in landmark-demo, if Template.timer.created throws an exception,\r\n// then it is never called again, even if you push the 'create a\r\n// timer' button again. the problem is almost certainly in afterFlush\r\n// (not hard to see what it is.)\r\n\r\nSpark = {};\r\nSparkTest = {};\r\n\r\nvar currentRenderer = (function () {\r\n  var current = null;\r\n  return {\r\n    get: function () {\r\n      return current;\r\n    },\r\n    withValue: function (v, func) {\r\n      var previous = current;\r\n      current = v;\r\n      try { return func(); }\r\n      finally { current = previous; }\r\n    }\r\n  };\r\n})();\r\n\r\nTAG = \"_spark_\" + Random.id();\r\nSparkTest.TAG = TAG;\r\n\r\n// We also export this as Spark._TAG due to a historical accident. I\r\n// don't know if anything uses it (possibly some of Chris Mather's\r\n// stuff?)  but let's keep exporting it since without it it would be\r\n// very difficult for code outside the spark package to, eg, walk\r\n// spark's liverange hierarchy.\r\nSpark._TAG = TAG;\r\n\r\n// XXX document contract for each type of annotation?\r\nvar ANNOTATION_NOTIFY = \"notify\";\r\nvar ANNOTATION_DATA = \"data\";\r\nvar ANNOTATION_ISOLATE = \"isolate\";\r\nvar ANNOTATION_EVENTS = \"events\";\r\nvar ANNOTATION_WATCH = \"watch\";\r\nvar ANNOTATION_LABEL = \"label\";\r\nvar ANNOTATION_LANDMARK = \"landmark\";\r\nvar ANNOTATION_LIST = \"list\";\r\nvar ANNOTATION_LIST_ITEM = \"item\";\r\n// XXX why do we need, eg, _ANNOTATION_ISOLATE? it has no semantics?\r\n\r\n// Use from tests to turn on extra UniversalEventListener sanity checks\r\nvar checkIECompliance = false;\r\nSparkTest.setCheckIECompliance = function (value) {\r\n  checkIECompliance = value;\r\n};\r\n\r\n// Private interface to 'preserve-inputs' package\r\nvar globalPreserves = {};\r\nSpark._addGlobalPreserve = function (selector, value) {\r\n  globalPreserves[selector] = value;\r\n};\r\n\r\n\r\nvar makeRange = function (type, start, end, inner) {\r\n  var range = new LiveRange(TAG, start, end, inner);\r\n  range.type = type;\r\n  return range;\r\n};\r\n\r\nvar findRangeOfType = function (type, node) {\r\n  var range = LiveRange.findRange(TAG, node);\r\n  while (range && range.type !== type)\r\n    range = range.findParent();\r\n\r\n  return range;\r\n};\r\n\r\nvar findParentOfType = function (type, range) {\r\n  do {\r\n    range = range.findParent();\r\n  } while (range && range.type !== type);\r\n\r\n  return range;\r\n};\r\n\r\nvar notifyWatchers = function (start, end) {\r\n  var tempRange = new LiveRange(TAG, start, end, true /* innermost */);\r\n  for (var walk = tempRange; walk; walk = walk.findParent())\r\n    if (walk.type === ANNOTATION_WATCH)\r\n      walk.notify();\r\n  tempRange.destroy();\r\n};\r\n\r\nvar eventGuardActive = false;\r\n// Spark does DOM manipulation inside an event guard to prevent events\r\n// like \"blur\" from firing.  It would be nice to deliver these events\r\n// in some cases, but running fresh event handling code on an invalid\r\n// LiveRange tree can easily produce errors.\r\n// This guard was motivated by seeing errors in Todos when switching\r\n// windows while an input field is focused.\r\nvar withEventGuard = function (func) {\r\n  var previous = eventGuardActive;\r\n  eventGuardActive = true;\r\n  try { return func(); }\r\n  finally { eventGuardActive = previous; }\r\n};\r\n\r\nRenderer = function () {\r\n  // Map from annotation ID to an annotation function, which is called\r\n  // at render time and receives (startNode, endNode).\r\n  this.annotations = {};\r\n\r\n  // Map from branch path to \"notes\" object, organized as a tree.\r\n  // Each node in the tree has child pointers named ('_'+label).\r\n  // Properties that don't start with '_' are arbitrary notes.\r\n  // For example, the \"happiness\" of the branch path consisting\r\n  // of labels \"foo\" and then \"bar\" would be\r\n  // `this._branchNotes._foo._bar.happiness`.\r\n  // Access to these notes is provided by LabelStack objects, of\r\n  // which `this.currentBranch` is one.\r\n  this._branchNotes = {};\r\n\r\n  // The label stack representing the current branch path we\r\n  // are in (based on calls to `Spark.labelBranch(label, htmlFunc)`).\r\n  this.currentBranch = this.newLabelStack();\r\n\r\n  // All landmark ranges created during this rendering.\r\n  this.landmarkRanges = [];\r\n\r\n  // Assembles the preservation information for patching.\r\n  this.pc = new PreservationController;\r\n};\r\n\r\n_.extend(Renderer.prototype, {\r\n  // `what` can be a function that takes a LiveRange, or just a set of\r\n  // attributes to add to the liverange.  type and what are optional.\r\n  // if no type is passed, no liverange will be created.\r\n  // If what is a function, it will be called no matter what, even\r\n  // if the annotated HTML was not used and no LiveRange was created,\r\n  // in which case it gets null as an argument.\r\n  annotate: function (html, type, what) {\r\n    if (typeof what !== 'function') {\r\n      var attribs = what;\r\n      what = function (range) {\r\n        if (range)\r\n          _.extend(range, attribs);\r\n      };\r\n    }\r\n    // The annotation tags that we insert into HTML strings must be\r\n    // unguessable in order to not create potential cross-site scripting\r\n    // attack vectors, so we use random strings.  Even a well-written app\r\n    // that avoids XSS vulnerabilities might, for example, put\r\n    // unescaped < and > in HTML attribute values, where they are normally\r\n    // safe.  We can't assume that a string like '<1>' came from us\r\n    // and not arbitrary user-entered data.\r\n    var id = (type || '') + \":\" + Random.id();\r\n    this.annotations[id] = function (start, end) {\r\n      if ((! start) || (! type)) {\r\n        // ! start: materialize called us with no args because this\r\n        // annotation wasn't used\r\n        // ! type: no type given, don't generate a LiveRange\r\n        what(null);\r\n        return;\r\n      }\r\n      var range = makeRange(type, start, end);\r\n      what(range);\r\n    };\r\n\r\n    return \"<$\" + id + \">\" + html + \"</$\" + id + \">\";\r\n  },\r\n\r\n  // A LabelStack is a mutable branch path that you can modify\r\n  // by pushing or popping labels.  At any time, you can ask for\r\n  // this Renderer's notes for the current branch path.\r\n  // Renderer's `currentBranch` field is a LabelStack, but you\r\n  // can create your own for the purpose of walking the branches\r\n  // and accessing notes.\r\n  newLabelStack: function () {\r\n    var stack = [this._branchNotes];\r\n    return {\r\n      pushLabel: function (label) {\r\n        var top = stack[stack.length - 1];\r\n        var key = '_' + label;\r\n        stack.push(top[key] = (top[key] || {}));\r\n      },\r\n      popLabel: function () {\r\n        stack.pop();\r\n      },\r\n      getNotes: function () {\r\n        var top = stack[stack.length - 1];\r\n        return top;\r\n      },\r\n      // Mark this branch with `getNotes()[prop] = true` and also\r\n      // walk up the stack marking parent branches (until an\r\n      // existing truthy value for `prop` is found).\r\n      // This makes it easy to test whether any descendent of a\r\n      // branch has the mark.\r\n      mark: function (prop) {\r\n        for (var i = stack.length - 1;\r\n             i >= 0 && ! stack[i][prop];\r\n             i--)\r\n          stack[i][prop] = true;\r\n      }\r\n    };\r\n  },\r\n\r\n  // Turn the `html` string into a fragment, applying the annotations\r\n  // from 'renderer' in the process.\r\n  materialize: function (htmlFunc) {\r\n    var self = this;\r\n\r\n    var html = currentRenderer.withValue(self, htmlFunc);\r\n    html = self.annotate(html); // wrap with an anonymous annotation\r\n\r\n    var fragById = {};\r\n    var replaceInclusions = function (container) {\r\n      var n = container.firstChild;\r\n      while (n) {\r\n        var next = n.nextSibling;\r\n        if (n.nodeType === 8) { // COMMENT\r\n          var frag = fragById[n.nodeValue];\r\n          if (frag === false) {\r\n            // id already used!\r\n            throw new Error(\"Spark HTML fragments may only be used once. \" +\r\n                            \"Second use in \" +\r\n                            DomUtils.fragmentToHtml(container));\r\n          } else if (frag) {\r\n            fragById[n.nodeValue] = false; // mark as used\r\n            DomUtils.wrapFragmentForContainer(frag, n.parentNode);\r\n            n.parentNode.replaceChild(frag, n);\r\n          }\r\n        } else if (n.nodeType === 1) { // ELEMENT\r\n          replaceInclusions(n);\r\n        }\r\n        n = next;\r\n      }\r\n    };\r\n\r\n    var bufferStack = [[]];\r\n    var idStack = [];\r\n    var ret;\r\n\r\n    var regex = /<(\\/?)\\$([^<>]+)>|<|[^<]+/g;\r\n    regex.lastIndex = 0;\r\n    var parts;\r\n    while ((parts = regex.exec(html))) {\r\n      var isOpen = ! parts[1];\r\n      var id = parts[2];\r\n      var annotationFunc = self.annotations[id];\r\n      if (annotationFunc === false) {\r\n        throw new Error(\"Spark HTML fragments may be used only once. \" +\r\n                        \"Second use of: \" +\r\n                        DomUtils.fragmentToHtml(fragById[id]));\r\n      } else if (! annotationFunc) {\r\n        bufferStack[bufferStack.length - 1].push(parts[0]);\r\n      } else if (isOpen) {\r\n        idStack.push(id);\r\n        bufferStack.push([]);\r\n      } else {\r\n        var idOnStack = idStack.pop();\r\n        if (idOnStack !== id)\r\n          throw new Error(\"Range mismatch: \" + idOnStack + \" / \" + id);\r\n        var frag = DomUtils.htmlToFragment(bufferStack.pop().join(''));\r\n        replaceInclusions(frag);\r\n        // empty frag becomes HTML comment <!--empty--> so we have start/end\r\n        // nodes to pass to the annotation function\r\n        if (! frag.firstChild)\r\n          frag.appendChild(document.createComment(\"empty\"));\r\n        annotationFunc(frag.firstChild, frag.lastChild);\r\n        self.annotations[id] = false; // mark as used\r\n        if (! idStack.length) {\r\n          // we're done; we just rendered the contents of the top-level\r\n          // annotation that we wrapped around htmlFunc ourselves.\r\n          // there may be unused fragments in fragById that include\r\n          // LiveRanges, but only if the user broke the rules by including\r\n          // an annotation somewhere besides element level, like inside\r\n          // an attribute (which is not allowed).\r\n          ret = frag;\r\n          break;\r\n        }\r\n        fragById[id] = frag;\r\n        bufferStack[bufferStack.length - 1].push('<!--' + id + '-->');\r\n      }\r\n    }\r\n\r\n    scheduleOnscreenSetup(ret, self.landmarkRanges);\r\n    self.landmarkRanges = [];\r\n\r\n    _.each(self.annotations, function(annotationFunc) {\r\n      if (annotationFunc)\r\n        // call annotation func with no arguments to mean \"you weren't used\"\r\n        annotationFunc();\r\n    });\r\n    self.annotations = {};\r\n\r\n    // Save original versions of every 'value' property. We want elements that\r\n    // have a value *attribute*, as well as form elements that have a value\r\n    // property but no value attribute (textarea and select).\r\n    //\r\n    // We save it in a one-element array expando. We use the array because IE8\r\n    // gets confused by expando properties with scalar values and exposes them\r\n    // as HTML attributes.\r\n    //\r\n    // We also save the values of CHECKED for radio and checkboxes.\r\n    _.each(DomUtils.findAll(ret, '[value], textarea, select'), function (node) {\r\n      node._sparkOriginalRenderedValue = [DomUtils.getElementValue(node)];\r\n    });\r\n    _.each(DomUtils.findAll(ret, 'input[type=checkbox], input[type=radio]'),\r\n           function (node) {\r\n      node._sparkOriginalRenderedChecked = [!!node.checked];\r\n    });\r\n\r\n    return ret;\r\n  }\r\n\r\n});\r\n\r\n// Decorator for Spark annotations that take `html` and are\r\n// pass-through without a renderer.  With this decorator,\r\n// the annotation routine gets the current renderer, and\r\n// if there isn't one returns `html` (the last argument).\r\nvar withRenderer = function (f) {\r\n  return function (/* arguments */) {\r\n    var renderer = currentRenderer.get();\r\n    var args = _.toArray(arguments);\r\n    if (!renderer)\r\n      return args.pop();\r\n    args.push(renderer);\r\n    return f.apply(null, args);\r\n  };\r\n};\r\n\r\n/******************************************************************************/\r\n/* Render and finalize                                                        */\r\n/******************************************************************************/\r\n\r\n// Schedule setup tasks to run at the next flush, which is when the\r\n// newly rendered fragment must be on the screen (if it doesn't want\r\n// to get garbage-collected.)\r\n//\r\n// 'landmarkRanges' is a list of the landmark ranges in 'frag'. It may be\r\n// omitted if frag doesn't contain any landmarks.\r\n//\r\n// XXX expose in the public API, eg as Spark.introduce(), so the user\r\n// can call it when manually inserting nodes? (via, eg, jQuery?) -- of\r\n// course in that case 'landmarkRanges' would be empty.\r\nvar scheduleOnscreenSetup = function (frag, landmarkRanges) {\r\n  var renderedRange = new LiveRange(TAG, frag);\r\n  var finalized = false;\r\n  renderedRange.finalize = function () {\r\n    finalized = true;\r\n  };\r\n\r\n  Deps.afterFlush(function () {\r\n    if (finalized)\r\n      return;\r\n\r\n    if (!DomUtils.isInDocument(renderedRange.firstNode())) {\r\n      // We've detected that some nodes were taken off the screen\r\n      // without calling Spark.finalize(). This could be because the\r\n      // user rendered them, but didn't insert them in the document\r\n      // before the next flush(). Or it could be because they used to\r\n      // be onscreen, but they were manually taken offscreen (eg, with\r\n      // jQuery) and the user neglected to call finalize() on the\r\n      // removed nodes. Help the user out by finalizing the entire\r\n      // subtree that is offscreen.\r\n      var node = renderedRange.firstNode();\r\n      while (node.parentNode)\r\n        node = node.parentNode;\r\n      if (node[\"_protect\"]) {\r\n        // test code can use this property to mark a root-level node\r\n        // (such as a DocumentFragment) as immune from\r\n        // autofinalization. effectively, the DocumentFragment is\r\n        // considered to be a first-class peer of `document`.\r\n      } else {\r\n        Spark.finalize(node);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Deliver render callbacks to all landmarks that are now\r\n    // onscreen (possibly not for the first time.)\r\n    _.each(landmarkRanges, function (landmarkRange) {\r\n      if (! landmarkRange.isPreservedConstant)\r\n        landmarkRange.rendered.call(landmarkRange.landmark);\r\n    });\r\n\r\n    // Deliver render callbacks to all landmarks that enclose the\r\n    // updated region.\r\n    //\r\n    // XXX unify with notifyWatchers. maybe remove _ANNOTATION_WATCH\r\n    // and just give everyone a contentsModified callback (sibling to\r\n    // 'finalize')\r\n    //\r\n    // future: include an argument in the callback to distinguish this\r\n    // case from the previous\r\n    var walk = renderedRange;\r\n    while ((walk = findParentOfType(ANNOTATION_LANDMARK, walk)))\r\n      walk.rendered.call(walk.landmark);\r\n\r\n    // This code can run several times on the same nodes (if the\r\n    // output of a render is included in a render), so it must be\r\n    // idempotent. This is not the best, asymptotically. There are\r\n    // things we could do to improve it.\r\n    notifyWatchers(renderedRange.firstNode(), renderedRange.lastNode());\r\n    renderedRange.destroy();\r\n  });\r\n};\r\n\r\nSpark.render = function (htmlFunc) {\r\n  var renderer = new Renderer;\r\n  var frag = renderer.materialize(htmlFunc);\r\n  return frag;\r\n};\r\n\r\n\r\n// Find all of all nodes and regions that should be preserved in\r\n// patching. Return a list of objects. There are two kinds of objects\r\n// in the list:\r\n//\r\n// A preserved node:\r\n//   {type: \"node\", from: Node, to: Node}\r\n//\r\n// A preserved (constant) region:\r\n//   {type: \"region\", fromStart: Node, fromEnd: Node,\r\n//      newRange: LiveRange}\r\n//\r\n// `existingRange` is the range in the document whose contents are to\r\n// be replaced. `newRange` holds the new contents and is not part of\r\n// the document DOM tree.  The implementation will temporarily reparent\r\n// the nodes in `newRange` into the document to check for selector matches.\r\nvar PreservationController = function () {\r\n  this.roots = []; // keys 'landmarkRange', 'fromRange', 'toRange'\r\n  this.regionPreservations = [];\r\n};\r\n\r\n_.extend(PreservationController.prototype, {\r\n  // Specify preservations that should be in effect on a fromRange/toRange\r\n  // pair.  If specified, `optContextNode` should be an ancestor node of\r\n  // fromRange that selectors are to be considered relative to.\r\n  addRoot: function (preserve, fromRange, toRange, optContextNode) {\r\n    var self = this;\r\n    self.roots.push({ context: optContextNode, preserve: preserve,\r\n                      fromRange: fromRange, toRange: toRange});\r\n  },\r\n\r\n  addConstantRegion: function (from, to) {\r\n    var self = this;\r\n    self.regionPreservations.push({\r\n      type: \"region\",\r\n      fromStart: from.firstNode(), fromEnd: from.lastNode(),\r\n      newRange: to\r\n    });\r\n  },\r\n\r\n  computePreservations: function (existingRange, newRange) {\r\n    var self = this;\r\n    var preservations = _.clone(self.regionPreservations);\r\n\r\n    var visitLabeledNodes = function (context, clipRange, nodeLabeler, selector, func) {\r\n      context = (context || clipRange.containerNode());\r\n      var nodes = DomUtils.findAllClipped(\r\n        context, selector, clipRange.firstNode(), clipRange.lastNode());\r\n\r\n      _.each(nodes, function (n) {\r\n        var label = nodeLabeler(n);\r\n        label && func(n, label);\r\n      });\r\n    };\r\n\r\n    // Find the old incarnation of each of the preserved nodes\r\n    _.each(self.roots, function (root) {\r\n      root.fromNodesByLabel = {};\r\n      _.each(root.preserve, function (nodeLabeler, selector) {\r\n        root.fromNodesByLabel[selector] = {};\r\n        visitLabeledNodes(\r\n          root.context, root.fromRange, nodeLabeler, selector,\r\n          function (n, label) {\r\n            root.fromNodesByLabel[selector][label] = n;\r\n          });\r\n      });\r\n    });\r\n\r\n    // Temporarily put newRange into the document so that we can do\r\n    // properly contextualized selector queries against it.\r\n    //\r\n    // Create a temporary range around newRange, and also around any enclosing\r\n    // ranges that happen to also start and end on those nodes.  It is ok\r\n    // to temporarily put these in the document as well, because CSS selectors\r\n    // don't care and we will put them back.  `tempRange` will hold our place\r\n    // in the tree `newRange` came from.\r\n    var tempRange = new LiveRange(TAG, newRange.firstNode(), newRange.lastNode());\r\n    var commentFrag = document.createDocumentFragment();\r\n    commentFrag.appendChild(document.createComment(\"\"));\r\n    var newRangeFrag = tempRange.replaceContents(commentFrag);\r\n    // `wrapperRange` will mark where we inserted newRange into the document.\r\n    var wrapperRange = new LiveRange(TAG, newRangeFrag);\r\n    existingRange.insertBefore(newRangeFrag);\r\n\r\n    _.each(self.roots, function (root) {\r\n      _.each(root.preserve, function (nodeLabeler, selector) {\r\n        visitLabeledNodes(root.context, root.toRange, nodeLabeler, selector, function (n, label) {\r\n          var match = root.fromNodesByLabel[selector][label];\r\n          if (match) {\r\n            preservations.push({ type: \"node\", from: match, to: n });\r\n            root.fromNodesByLabel[selector][label] = null;\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    // Extraction is legal because we're just taking the document\r\n    // back to the state it was in before insertBefore.\r\n    var extractedFrag = wrapperRange.extract();\r\n    wrapperRange.destroy();\r\n    tempRange.replaceContents(extractedFrag);\r\n    tempRange.destroy();\r\n\r\n    return preservations;\r\n  }\r\n});\r\n\r\n\r\n// XXX debugging\r\nvar pathForRange = function (r) {\r\n  var path = [], r;\r\n  while ((r = findParentOfType(ANNOTATION_LABEL, r)))\r\n    path.unshift(r.label);\r\n  return path.join(' :: ');\r\n};\r\n\r\n// `range` is a region of `document`. Modify it in-place so that it\r\n// matches the result of Spark.render(htmlFunc), preserving landmarks.\r\n//\r\nSpark.renderToRange = function (range, htmlFunc) {\r\n  // `range` may be out-of-document and we don't check here.\r\n  // XXX should we?\r\n  //\r\n  // Explicit finalization of ranges (done within Spark or by a call to\r\n  // Spark.finalize) prevents us from being called in the first place.\r\n  // The newly rendered material will be checked to see if it's in the\r\n  // document by scheduleOnscreenSetUp's scheduled setup.\r\n  // However, if range is not valid, bail out now before running\r\n  // htmlFunc.\r\n  var startNode = range.firstNode();\r\n  if (! startNode || ! startNode.parentNode)\r\n    return;\r\n\r\n  var renderer = new Renderer();\r\n\r\n  // Call 'func' for each landmark in 'range'. Pass two arguments to\r\n  // 'func', the range, and an extra \"notes\" object such that two\r\n  // landmarks receive the same (===) notes object iff they have the\r\n  // same branch path. 'func' can write to the notes object so long as\r\n  // it limits itself to attributes that do not start with '_'.\r\n  var visitLandmarksInRange = function (range, func) {\r\n    var stack = renderer.newLabelStack();\r\n\r\n    range.visit(function (isStart, r) {\r\n      if (r.type === ANNOTATION_LABEL) {\r\n        if (isStart)\r\n          stack.pushLabel(r.label);\r\n        else\r\n          stack.popLabel();\r\n      } else if (r.type === ANNOTATION_LANDMARK && isStart) {\r\n        func(r, stack.getNotes());\r\n      }\r\n    });\r\n  };\r\n\r\n  // Find all of the landmarks in the old contents of the range\r\n  visitLandmarksInRange(range, function (landmarkRange, notes) {\r\n    notes.originalRange = landmarkRange;\r\n  });\r\n\r\n  // Once we render the new fragment, as soon as it is placed into the DOM (even\r\n  // temporarily), if any radio buttons in the new framgent are checked, any\r\n  // radio buttons with the same name in the entire document will be unchecked\r\n  // (since only one radio button of a given name can be checked at a time). So\r\n  // we save the current checked value of all radio buttons in an expando.\r\n  var radios = DomUtils.findAllClipped(\r\n    range.containerNode(), 'input[type=radio]',\r\n    range.firstNode(), range.lastNode());\r\n  _.each(radios, function (node) {\r\n    node._currentChecked = [!!node.checked];\r\n  });\r\n\r\n  var frag = renderer.materialize(htmlFunc);\r\n\r\n  DomUtils.wrapFragmentForContainer(frag, range.containerNode());\r\n\r\n  var tempRange = new LiveRange(TAG, frag);\r\n\r\n  // find preservation roots from matched landmarks inside the\r\n  // rerendered region\r\n  var pc = renderer.pc;\r\n  visitLandmarksInRange(\r\n    tempRange, function (landmarkRange, notes) {\r\n      if (notes.originalRange) {\r\n        if (landmarkRange.constant)\r\n          pc.addConstantRegion(notes.originalRange, landmarkRange);\r\n\r\n        pc.addRoot(landmarkRange.preserve,\r\n                   notes.originalRange, landmarkRange);\r\n      }\r\n    });\r\n\r\n  // find preservation roots that come from landmarks enclosing the\r\n  // updated region\r\n  var walk = range;\r\n  while ((walk = walk.findParent())) {\r\n    if (! walk.firstNode().parentNode)\r\n      // we're in a DOM island with a top-level range (not really\r\n      // allowed, but could happen if `range` is on nodes that\r\n      // manually removed.\r\n      // XXX check for this sooner; hard to reason about this function\r\n      // on a \"malformed\" liverange tree\r\n      break;\r\n\r\n    if (walk.type === ANNOTATION_LANDMARK, walk)\r\n      pc.addRoot(walk.preserve, range, tempRange, walk.containerNode());\r\n  }\r\n\r\n  pc.addRoot(globalPreserves, range, tempRange);\r\n\r\n  // compute preservations (must do this before destroying tempRange)\r\n  var preservations = pc.computePreservations(range, tempRange);\r\n\r\n  tempRange.destroy();\r\n\r\n  var results = {};\r\n\r\n  // Patch! (using preservations)\r\n  withEventGuard(function () {\r\n    range.operate(function (start, end) {\r\n      // XXX this will destroy all liveranges, including ones\r\n      // inside constant regions whose DOM nodes we are going\r\n      // to preserve untouched\r\n      Spark.finalize(start, end);\r\n      patch(start.parentNode, frag, start.previousSibling,\r\n            end.nextSibling, preservations, results);\r\n    });\r\n  });\r\n\r\n  _.each(results.regionPreservations, function (landmarkRange) {\r\n    // Rely on the fact that computePreservations only emits\r\n    // region preservations whose ranges are landmarks.\r\n    // This flag means that landmarkRange is a new constant landmark\r\n    // range that matched an old one *and* was DOM-preservable by\r\n    // the patcher.\r\n    landmarkRange.isPreservedConstant = true;\r\n  });\r\n};\r\n\r\n// Delete all of the liveranges in the range of nodes between `start`\r\n// and `end`, and call their 'finalize' function if any. Or instead of\r\n// `start` and `end` you may pass a fragment in `start`.\r\n//\r\nSpark.finalize = function (start, end) {\r\n  if (! start.parentNode && start.nodeType !== 11 /* DocumentFragment */) {\r\n    // Workaround for LiveRanges' current inability to contain\r\n    // a node with no parentNode.\r\n    var frag = document.createDocumentFragment();\r\n    frag.appendChild(start);\r\n    start = frag;\r\n    end = null;\r\n  }\r\n  var wrapper = new LiveRange(TAG, start, end);\r\n  wrapper.visit(function (isStart, range) {\r\n    isStart && range.finalize && range.finalize();\r\n  });\r\n  wrapper.destroy(true /* recursive */);\r\n};\r\n\r\n/******************************************************************************/\r\n/* Data contexts                                                              */\r\n/******************************************************************************/\r\n\r\nSpark.setDataContext = withRenderer(function (dataContext, html, _renderer) {\r\n  return _renderer.annotate(\r\n    html, ANNOTATION_DATA, { data: dataContext });\r\n});\r\n\r\nSpark.getDataContext = function (node) {\r\n  var range = findRangeOfType(ANNOTATION_DATA, node);\r\n  return range && range.data;\r\n};\r\n\r\n/******************************************************************************/\r\n/* Events                                                                     */\r\n/******************************************************************************/\r\n\r\nvar universalListener = null;\r\nvar getListener = function () {\r\n  if (!universalListener)\r\n    universalListener = new UniversalEventListener(function (event) {\r\n      // Handle a currently-propagating event on a particular node.\r\n      // We walk each enclosing liverange of the node and offer it the\r\n      // chance to handle the event. It's range.handler's\r\n      // responsibility to check isImmediatePropagationStopped()\r\n      // before delivering events to the user. We precompute the list\r\n      // of enclosing liveranges to defend against the case where user\r\n      // event handlers change the DOM.\r\n\r\n      if (eventGuardActive)\r\n        // swallow the event\r\n        return;\r\n\r\n      var ranges = [];\r\n      var walk = findRangeOfType(ANNOTATION_EVENTS,\r\n                                 event.currentTarget);\r\n      while (walk) {\r\n        ranges.push(walk);\r\n        walk = findParentOfType(ANNOTATION_EVENTS, walk);\r\n      }\r\n      _.each(ranges, function (r) {\r\n        r.handler(event);\r\n      });\r\n    }, checkIECompliance);\r\n\r\n  return universalListener;\r\n};\r\n\r\nSpark.attachEvents = withRenderer(function (eventMap, html, _renderer) {\r\n  var listener = getListener();\r\n\r\n  var handlerMap = {}; // type -> [{selector, callback}, ...]\r\n  // iterate over eventMap, which has form {\"type selector, ...\": callbacks},\r\n  // callbacks can either be a fn, or an array of fns\r\n  // and populate handlerMap\r\n  _.each(eventMap, function(callbacks, spec) {\r\n    if ('function' === typeof callbacks) {\r\n      callbacks = [ callbacks ];\r\n    }\r\n    var clauses = spec.split(/,\\s+/);\r\n    // iterate over clauses of spec, e.g. ['click .foo', 'click .bar']\r\n    _.each(clauses, function (clause) {\r\n      var parts = clause.split(/\\s+/);\r\n      if (parts.length === 0)\r\n        return;\r\n\r\n      var type = parts.shift();\r\n      var selector = parts.join(' ');\r\n\r\n      handlerMap[type] = handlerMap[type] || [];\r\n      _.each(callbacks, function(callback) {\r\n        handlerMap[type].push({selector: selector, callback: callback});\r\n      });\r\n    });\r\n  });\r\n\r\n  var eventTypes = _.keys(handlerMap);\r\n\r\n  var installHandlers = function (range) {\r\n    _.each(eventTypes, function (t) {\r\n      for(var n = range.firstNode(),\r\n              after = range.lastNode().nextSibling;\r\n          n && n !== after;\r\n          n = n.nextSibling)\r\n        listener.installHandler(n, t);\r\n    });\r\n  };\r\n\r\n  html = _renderer.annotate(\r\n    html, ANNOTATION_WATCH, {\r\n      notify: function () {\r\n        installHandlers(this);\r\n      }\r\n    });\r\n\r\n  var finalized = false;\r\n\r\n  html = _renderer.annotate(\r\n    html, ANNOTATION_EVENTS, function (range) {\r\n      if (! range)\r\n        return;\r\n\r\n      _.each(eventTypes, function (t) {\r\n        listener.addType(t);\r\n      });\r\n      installHandlers(range);\r\n\r\n      range.finalize = function () {\r\n        finalized = true;\r\n      };\r\n\r\n      range.handler = function (event) {\r\n        var handlers = handlerMap[event.type] || [];\r\n\r\n        for (var i = 0; i < handlers.length; i++) {\r\n          if (finalized || event.isImmediatePropagationStopped())\r\n            return;\r\n\r\n          var handler = handlers[i];\r\n          var callback = handler.callback;\r\n          var selector = handler.selector;\r\n\r\n          if (selector) {\r\n            if (! DomUtils.matchesSelectorClipped(\r\n              event.currentTarget, range.containerNode(), selector,\r\n              range.firstNode(), range.lastNode())) {\r\n              continue;\r\n            }\r\n          } else {\r\n            // if no selector, only match the event target\r\n            if (event.currentTarget !== event.target)\r\n              continue;\r\n          }\r\n\r\n          // Found a matching handler. Call it.\r\n          var eventData = Spark.getDataContext(event.currentTarget) || {};\r\n          var landmarkRange =\r\n                findParentOfType(ANNOTATION_LANDMARK, range);\r\n          var landmark = (landmarkRange && landmarkRange.landmark);\r\n\r\n          // Note that the handler can do arbitrary things, like call\r\n          // Deps.flush() or otherwise remove and finalize parts of\r\n          // the DOM.  We can't assume `range` is valid past this point,\r\n          // and we'll check the `finalized` flag at the top of the loop.\r\n          var returnValue = callback.call(eventData, event, landmark);\r\n\r\n          // allow app to `return false` from event handler, just like\r\n          // you can in a jquery event handler\r\n          if (returnValue === false) {\r\n            event.stopImmediatePropagation();\r\n            event.preventDefault();\r\n          }\r\n        }\r\n      };\r\n    });\r\n\r\n  return html;\r\n});\r\n\r\n/******************************************************************************/\r\n/* Isolate                                                                    */\r\n/******************************************************************************/\r\n\r\nSpark.isolate = function (htmlFunc) {\r\n  var renderer = currentRenderer.get();\r\n  if (!renderer)\r\n    return htmlFunc();\r\n\r\n  var range;\r\n  var firstRun = true;\r\n  var retHtml;\r\n  Deps.autorun(function (handle) {\r\n    if (firstRun) {\r\n      retHtml = renderer.annotate(\r\n        htmlFunc(), ANNOTATION_ISOLATE,\r\n        function (r) {\r\n          if (! r) {\r\n            // annotation not used; kill this autorun\r\n            handle.stop();\r\n          } else {\r\n            range = r;\r\n            range.finalize = function () {\r\n              // Spark.finalize() was called on our range (presumably\r\n              // because it was removed from the document.)  Kill\r\n              // this autorun.\r\n              handle.stop();\r\n            };\r\n          }\r\n        });\r\n      firstRun = false;\r\n    } else {\r\n      Spark.renderToRange(range, htmlFunc);\r\n    }\r\n  });\r\n\r\n  return retHtml;\r\n};\r\n\r\n/******************************************************************************/\r\n/* Lists                                                                      */\r\n/******************************************************************************/\r\n\r\n// XXX duplicated code from minimongo.js.  It's small though.\r\nvar applyChanges = function (doc, changeFields) {\r\n  _.each(changeFields, function (value, key) {\r\n    if (value === undefined)\r\n      delete doc[key];\r\n    else\r\n      doc[key] = value;\r\n  });\r\n};\r\n\r\n\r\n// If minimongo is available (it's a weak dependency) use its ID stringifier (so\r\n// that, eg, ObjectId and strings don't overlap). Otherwise just use the\r\n// identity function.\r\n// This is also used in convenience.js.\r\nidStringify = Package.minimongo\r\n  ? Package.minimongo.LocalCollection._idStringify\r\n  : function (id) { return id; };\r\n\r\nSpark.list = function (cursor, itemFunc, elseFunc) {\r\n  elseFunc = elseFunc || function () { return ''; };\r\n\r\n  // Create a level of indirection around our cursor callbacks so we\r\n  // can change them later\r\n  var callbacks = {};\r\n  var observerCallbacks = {};\r\n  _.each([\"addedBefore\", \"removed\", \"movedBefore\", \"changed\"], function (name) {\r\n    observerCallbacks[name] = function () {\r\n      return callbacks[name].apply(null, arguments);\r\n    };\r\n  });\r\n\r\n  // Get the current contents of the cursor.\r\n\r\n  var itemDict = new OrderedDict(idStringify);\r\n  _.extend(callbacks, {\r\n    addedBefore: function (id, item, before) {\r\n      var doc = EJSON.clone(item);\r\n      doc._id = id;\r\n      var elt = {doc: doc, liveRange: null};\r\n      itemDict.putBefore(id, elt, before);\r\n    }\r\n  });\r\n  var handle = cursor.observeChanges(observerCallbacks);\r\n\r\n  // Get the renderer, if any\r\n  var renderer = currentRenderer.get();\r\n  var maybeAnnotate = renderer ?\r\n        _.bind(renderer.annotate, renderer) :\r\n    function (html) { return html; };\r\n\r\n  // Templates should have access to data and methods added by the\r\n  // transformer, but observeChanges doesn't transform, so we have to do\r\n  // it here.\r\n  //\r\n  // NOTE: this is a little bit of an abstraction violation. Ideally,\r\n  // the only thing Spark should know about Minimongo is the contract of\r\n  // observeChanges. In theory, anything that implements observeChanges\r\n  // could be passed to Spark.list. But meh.\r\n  var transformedDoc = function (doc) {\r\n    if (cursor.getTransform && cursor.getTransform())\r\n      return cursor.getTransform()(EJSON.clone(doc));\r\n    return doc;\r\n  };\r\n\r\n  // Render the initial contents. If we have a renderer, create a\r\n  // range around each item as well as around the list, and save them\r\n  // off for later.\r\n  var html = '';\r\n  var outerRange;\r\n  if (itemDict.empty())\r\n    html = elseFunc();\r\n  else {\r\n    itemDict.forEach(function (elt) {\r\n        html += maybeAnnotate(\r\n          itemFunc(transformedDoc(elt.doc)),\r\n          ANNOTATION_LIST_ITEM,\r\n          function (range) {\r\n            elt.liveRange = range;\r\n          });\r\n    });\r\n  }\r\n  var stopped = false;\r\n  var cleanup = function () {\r\n    handle.stop();\r\n    stopped = true;\r\n  };\r\n  html = maybeAnnotate(html, ANNOTATION_LIST, function (range) {\r\n    if (! range) {\r\n      // We never ended up on the screen (caller discarded our return\r\n      // value)\r\n      cleanup();\r\n    } else {\r\n      outerRange = range;\r\n      outerRange.finalize = cleanup;\r\n    }\r\n  });\r\n\r\n  // No renderer? Then we have no way to update the returned html and\r\n  // we can close the observer.\r\n  if (! renderer)\r\n    cleanup();\r\n\r\n  // Called by `removed` and `moved` in order to cause render callbacks on\r\n  // parent landmarks.\r\n  // XXX This is not the final solution.  1) This code should be unified\r\n  // with the code in scheduleOnscreenSetup.  2) In general, lists are\r\n  // going to cause a lot of callbacks (one per collection callback).\r\n  // Maybe that will make sense if we give render callbacks subrange info.\r\n  var notifyParentsRendered = function () {\r\n    var walk = outerRange;\r\n    while ((walk = findParentOfType(ANNOTATION_LANDMARK, walk)))\r\n      walk.rendered.call(walk.landmark);\r\n  };\r\n\r\n  var later = function (f) {\r\n    Deps.afterFlush(function () {\r\n      if (! stopped)\r\n        withEventGuard(f);\r\n    });\r\n  };\r\n\r\n  // The DOM update callbacks.\r\n  _.extend(callbacks, {\r\n    addedBefore: function (id, fields, before) {\r\n      later(function () {\r\n        var doc = EJSON.clone(fields);\r\n        doc._id = id;\r\n        var frag = Spark.render(_.bind(itemFunc, null, transformedDoc(doc)));\r\n        DomUtils.wrapFragmentForContainer(frag, outerRange.containerNode());\r\n        var range = makeRange(ANNOTATION_LIST_ITEM, frag);\r\n\r\n        if (itemDict.empty()) {\r\n          Spark.finalize(outerRange.replaceContents(frag));\r\n        } else if (before === null) {\r\n          itemDict.lastValue().liveRange.insertAfter(frag);\r\n        } else {\r\n          itemDict.get(before).liveRange.insertBefore(frag);\r\n        }\r\n        itemDict.putBefore(id, {doc: doc, liveRange: range}, before);\r\n      });\r\n    },\r\n\r\n    removed: function (id) {\r\n      later(function () {\r\n        if (itemDict.first() === itemDict.last()) {\r\n          var frag = Spark.render(elseFunc);\r\n          DomUtils.wrapFragmentForContainer(frag, outerRange.containerNode());\r\n          Spark.finalize(outerRange.replaceContents(frag));\r\n        } else\r\n          Spark.finalize(itemDict.get(id).liveRange.extract());\r\n\r\n        itemDict.remove(id);\r\n\r\n        notifyParentsRendered();\r\n      });\r\n    },\r\n\r\n    movedBefore: function (id, before) {\r\n      later(function () {\r\n        var frag = itemDict.get(id).liveRange.extract();\r\n        if (before === null) {\r\n          itemDict.lastValue().liveRange.insertAfter(frag);\r\n        }\r\n        else {\r\n          itemDict.get(before).liveRange.insertBefore(frag);\r\n        }\r\n        itemDict.moveBefore(id, before);\r\n        notifyParentsRendered();\r\n      });\r\n    },\r\n\r\n    changed: function (id, fields) {\r\n      later(function () {\r\n        var elt = itemDict.get(id);\r\n        if (!elt)\r\n          throw new Error(\"Unknown id for changed: \" + id);\r\n        applyChanges(elt.doc, fields);\r\n        Spark.renderToRange(elt.liveRange,\r\n                            _.bind(itemFunc, null, transformedDoc(elt.doc)));\r\n      });\r\n    }\r\n  });\r\n\r\n  return html;\r\n};\r\n\r\n/******************************************************************************/\r\n/* Labels and landmarks                                                       */\r\n/******************************************************************************/\r\n\r\nvar nextLandmarkId = 1;\r\n\r\nSpark.Landmark = function () {\r\n  this.id = nextLandmarkId++;\r\n  this._range = null; // will be set when put onscreen\r\n};\r\n\r\n_.extend(Spark.Landmark.prototype, {\r\n  firstNode: function () {\r\n    return this._range.firstNode();\r\n  },\r\n  lastNode: function () {\r\n    return this._range.lastNode();\r\n  },\r\n  find: function (selector) {\r\n    var r = this._range;\r\n    return DomUtils.findClipped(r.containerNode(), selector,\r\n                                r.firstNode(), r.lastNode());\r\n  },\r\n  findAll: function (selector) {\r\n    var r = this._range;\r\n    return DomUtils.findAllClipped(r.containerNode(), selector,\r\n                                   r.firstNode(), r.lastNode());\r\n  },\r\n  hasDom: function () {\r\n    return !! this._range;\r\n  }\r\n});\r\n\r\nSpark.UNIQUE_LABEL = ['UNIQUE_LABEL'];\r\n\r\n// label must be a string.\r\n// or pass label === null to not drop a label after all (meaning that\r\n// this function is a noop)\r\n//\r\nSpark.labelBranch = function (label, htmlFunc) {\r\n  var renderer = currentRenderer.get();\r\n  if (! renderer || label === null)\r\n    return htmlFunc();\r\n\r\n  if (label === Spark.UNIQUE_LABEL)\r\n    label = Random.id();\r\n\r\n  renderer.currentBranch.pushLabel(label);\r\n  var html = htmlFunc();\r\n  var occupied = renderer.currentBranch.getNotes().occupied;\r\n  renderer.currentBranch.popLabel();\r\n\r\n  if (! occupied)\r\n    // don't create annotation if branch doesn't contain any landmarks.\r\n    // if this label isn't on an element-level HTML boundary, then that\r\n    // is certainly the case.\r\n    return html;\r\n\r\n  return renderer.annotate(\r\n    html, ANNOTATION_LABEL, { label: label });\r\n\r\n  // XXX what happens if the user doesn't use the return value, or\r\n  // doesn't use it directly, eg, swaps the branches of the tree\r\n  // around? \"that's an error?\" the result would be that the apparent\r\n  // branch path of a landmark at render time would be different from\r\n  // its apparent branch path in the actual document. seems like the\r\n  // answer is to have labelBranch not drop an annotation, and keep\r\n  // the branch label info outside of the DOM in a parallel tree of\r\n  // labels and landmarks (likely similar to the one we're already\r\n  // keeping?) a little tricky since not every node in the label tree\r\n  // is actually populated with a landmark? (though we could change\r\n  // that I guess -- they would be landmarks without any specific DOM\r\n  // nodes?)\r\n};\r\n\r\nSpark.createLandmark = function (options, htmlFunc) {\r\n  var renderer = currentRenderer.get();\r\n  if (! renderer) {\r\n    // no renderer -- create and destroy Landmark inline\r\n    var landmark = new Spark.Landmark;\r\n    options.created && options.created.call(landmark);\r\n    var html = htmlFunc(landmark);\r\n    options.destroyed && options.destroyed.call(landmark);\r\n    return html;\r\n  }\r\n\r\n  // Normalize preserve map\r\n  var preserve = {};\r\n  if (_.isArray(options.preserve))\r\n    _.each(options.preserve, function (selector) {\r\n      preserve[selector] = true;\r\n    });\r\n  else\r\n    preserve = options.preserve || {};\r\n  for (var selector in preserve)\r\n    if (typeof preserve[selector] !== 'function')\r\n      preserve[selector] = function () { return true; };\r\n\r\n  renderer.currentBranch.mark('occupied');\r\n  var notes = renderer.currentBranch.getNotes();\r\n  var landmark;\r\n  if (notes.originalRange) {\r\n    if (notes.originalRange.superceded)\r\n      throw new Error(\"Can't create second landmark in same branch\");\r\n    notes.originalRange.superceded = true; // prevent destroyed(), second match\r\n    landmark = notes.originalRange.landmark; // the old Landmark\r\n  } else {\r\n    landmark = new Spark.Landmark;\r\n    if (options.created) {\r\n      // Run callback outside the current Spark.isolate's deps context.\r\n      Deps.nonreactive(function () {\r\n        options.created.call(landmark);\r\n      });\r\n    }\r\n  }\r\n  notes.landmark = landmark;\r\n\r\n  var html = htmlFunc(landmark);\r\n  return renderer.annotate(\r\n    html, ANNOTATION_LANDMARK, function (range) {\r\n      if (! range) {\r\n        // annotation not used\r\n        options.destroyed && options.destroyed.call(landmark);\r\n        return;\r\n      }\r\n\r\n      _.extend(range, {\r\n        preserve: preserve,\r\n        constant: !! options.constant,\r\n        rendered: options.rendered || function () {},\r\n        destroyed: options.destroyed || function () {},\r\n        landmark: landmark,\r\n        finalize: function () {\r\n          if (! this.superceded) {\r\n            this.landmark._range = null;\r\n            this.destroyed.call(this.landmark);\r\n          }\r\n        }\r\n      });\r\n\r\n      landmark._range = range;\r\n      renderer.landmarkRanges.push(range);\r\n      // Help GC avoid an actual memory leak (#1157) by nulling the\r\n      // `renderer` local variable, which holds data structures about\r\n      // the preservation and patching performed during this rendering\r\n      // pass, including references to the old LiveRanges.  If\r\n      // `renderer` is retained by the LiveRange we initialize here,\r\n      // it creates a chain linking the new LiveRanges to the\r\n      // renderer, to the old LiveRanges, to the old renderer, etc.\r\n      //\r\n      // The reason the new LiveRange might retains `renderer` has to\r\n      // do with how V8 implements closures.  V8 considers\r\n      // `range.finalize` to close over `renderer`, even though it\r\n      // doesn't use it.  Because `renderer` is used by *some* nested\r\n      // closure, it apparently is retained by all nested closures as\r\n      // part of `Spark.createLandmark`'s function context.\r\n      renderer = null;\r\n    });\r\n};\r\n\r\nSparkTest.getEnclosingLandmark = function (node) {\r\n  var range = findRangeOfType(ANNOTATION_LANDMARK, node);\r\n  return range ? range.landmark : null;\r\n};\r\n","patch = function(tgtParent, srcParent, tgtBefore, tgtAfter, preservations,\r\n                 results) {\r\n\r\n  var copyFunc = function(t, s) {\r\n    LiveRange.transplantTag(TAG, t, s);\r\n  };\r\n\r\n  var patcher = new Patcher(\r\n    tgtParent, srcParent, tgtBefore, tgtAfter);\r\n\r\n\r\n  var visitNodes = function(parent, before, after, func) {\r\n    for(var n = before ? before.nextSibling : parent.firstChild;\r\n        n && n !== after;\r\n        n = n.nextSibling) {\r\n      if (func(n) !== false && n.firstChild)\r\n        visitNodes(n, null, null, func);\r\n    }\r\n  };\r\n\r\n  // results arg is optional; it is mutated if provided; returned either way\r\n  results = (results || {});\r\n  // array of LiveRanges that were successfully preserved from\r\n  // the region preservations\r\n  var regionPreservations = (results.regionPreservations =\r\n                             results.regionPreservations || []);\r\n\r\n  var lastTgtMatch = null;\r\n\r\n  visitNodes(srcParent, null, null, function(src) {\r\n    // XXX inefficient to scan for match for every node!\r\n    // We could at least skip non-element nodes, except for \"range matches\"\r\n    // used for constant chunks, which may begin on a non-element.\r\n    // But really this shouldn't be a linear search.\r\n    var pres = _.find(preservations, function (p) {\r\n      // find preserved region starting at `src`, if any\r\n      return p.type === 'region' && p.newRange.firstNode() === src;\r\n    }) || _.find(preservations, function (p) {\r\n      // else, find preservation of `src`\r\n      return p.type === 'node' && p.to === src;\r\n    });\r\n\r\n    if (pres) {\r\n      var tgt = (pres.type === 'region' ? pres.fromStart : pres.from);\r\n      if (! lastTgtMatch ||\r\n          DomUtils.compareElementIndex(lastTgtMatch, tgt) < 0) {\r\n        if (pres.type === 'region') {\r\n          // preserved region for constant landmark\r\n          if (patcher.match(pres.fromStart, pres.newRange.firstNode(),\r\n                            copyFunc, true)) {\r\n            patcher.skipToSiblings(pres.fromEnd, pres.newRange.lastNode());\r\n            // without knowing or caring what DOM nodes are in pres.newRange,\r\n            // transplant the range data to pres.fromStart and pres.fromEnd\r\n            // (including references to enclosing ranges).\r\n            LiveRange.transplantRange(\r\n              pres.fromStart, pres.fromEnd, pres.newRange);\r\n            regionPreservations.push(pres.newRange);\r\n          }\r\n        } else if (pres.type === 'node') {\r\n          if (patcher.match(tgt, src, copyFunc)) {\r\n            // match succeeded\r\n            lastTgtMatch = tgt;\r\n            if (tgt.firstChild || src.firstChild) {\r\n              if (tgt.nodeName !== \"TEXTAREA\" && tgt.nodeName !== \"SELECT\") {\r\n                // Don't patch contents of TEXTAREA tag (which are only the\r\n                // initial contents but may affect the tag's .value in IE) or of\r\n                // SELECT (which is specially handled in _copyAttributes).\r\n                // Otherwise recurse!\r\n                patch(tgt, src, null, null, preservations);\r\n              }\r\n            }\r\n            return false; // tell visitNodes not to recurse\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  });\r\n\r\n  patcher.finish();\r\n\r\n  return results;\r\n};\r\n\r\n\r\n// A Patcher manages the controlled replacement of a region of the DOM.\r\n// The target region is changed in place to match the source region.\r\n//\r\n// The target region consists of the children of tgtParent, extending from\r\n// the child after tgtBefore to the child before tgtAfter.  A null\r\n// or absent tgtBefore or tgtAfter represents the beginning or end\r\n// of tgtParent's children.  The source region consists of all children\r\n// of srcParent, which may be a DocumentFragment.\r\n//\r\n// To use a new Patcher, call `match` zero or more times followed by\r\n// `finish`.\r\n//\r\n// A match is a correspondence between an old node in the target region\r\n// and a new node in the source region that will replace it.  Based on\r\n// this correspondence, the target node is preserved and the attributes\r\n// and children of the source node are copied over it.  The `match`\r\n// method declares such a correspondence.  A Patcher that makes no matches,\r\n// for example, just removes the target nodes and inserts the source nodes\r\n// in their place.\r\n//\r\n// Constructor:\r\nPatcher = function(tgtParent, srcParent, tgtBefore, tgtAfter) {\r\n  this.tgtParent = tgtParent;\r\n  this.srcParent = srcParent;\r\n\r\n  this.tgtBefore = tgtBefore;\r\n  this.tgtAfter = tgtAfter;\r\n\r\n  this.lastKeptTgtNode = null;\r\n  this.lastKeptSrcNode = null;\r\n};\r\n\r\n\r\n// Advances the patching process up to tgtNode in the target tree,\r\n// and srcNode in the source tree.  tgtNode will be preserved, with\r\n// the attributes of srcNode copied over it, in essence identifying\r\n// the two nodes with each other.  The same treatment is given to\r\n// any parents of the nodes that are newly implicated as corresponding.\r\n// In the process of traversing from the last matched nodes to these\r\n// ones, all nodes \"in between\" in the target document, at any level,\r\n// are removed, and all nodes \"in between\" in the source document\r\n// are copied over to their appropriate positions.\r\n//\r\n// For example, if match() is called only once, and then finish()\r\n// is called, the effect is to preserve tgtNode, its children,\r\n// and its ancestors (parent chain), while swapping out all its\r\n// siblings and the siblings of its ancestors, so that the target\r\n// tree is mutated to look like the source tree did.\r\n//\r\n// The caller is responsible for ensuring the precondition that\r\n// subsequent tgtNodes and subsequent srcNodes are strictly \"in order.\"\r\n// The ordering referred to here is a partial order in which A comes\r\n// before B if their tags would be disjoint in HTML, i.e. the end of\r\n// A comes before the beginning of B.  Put another way, there is some\r\n// ancestor of A and some ancestor of B that have the same parent,\r\n// are different, and are in order.\r\n//\r\n// There are other requirements for two nodes to be \"matched,\"\r\n// but match() can detect them and exit gracefully returning false.\r\n// For example, the tag-names must be the same, and the tag-names\r\n// of their parents.  More subtly, it may be impossible to match\r\n// the parents of tgtNode or srcNode because they have been\r\n// previously matched.  If we are to match a series of P tags\r\n// that are each inside one DIV, for example, is it the same DIV\r\n// or not?  If the source and target disagree, we will have to\r\n// reparent one of the Ps.  Users should not be moving identified\r\n// nodes, but we want to still be correct (fall back on replacement)\r\n// if they do.\r\n//\r\n// If false is returned, the match was impossible, but patching\r\n// can continue and will still be otherwise correct.  The next call\r\n// to match() must still obey the order constraint, as the patcher\r\n// internally only moves forwards and patches as it goes.\r\n//\r\n// copyCallback is called on every new matched (tgt, src) pair\r\n// right after copying attributes.  It's a good time to transplant\r\n// liveranges and patch children.\r\nPatcher.prototype.match = function(\r\n  tgtNode, srcNode, copyCallback, onlyAdvance) {\r\n\r\n  // last nodes \"kept\" (matched/identified with each other)\r\n  var lastKeptTgt = this.lastKeptTgtNode;\r\n  var lastKeptSrc = this.lastKeptSrcNode;\r\n  // nodes to match and keep, this time around\r\n  var tgt = tgtNode;\r\n  var src = srcNode;\r\n\r\n  if ((! tgt) != (! src)) {\r\n    return false; // truthinesses don't match\r\n  }\r\n\r\n  var starting = ! lastKeptTgt;\r\n  var finishing = ! tgt;\r\n\r\n  if (! starting) {\r\n    // move lastKeptTgt/lastKeptSrc forward and out,\r\n    // until they are siblings of tgt/src or of an ancestor of tgt/src,\r\n    // replacing as we go.  If tgt/src is falsy, we make it to the\r\n    // top level.\r\n    while (lastKeptTgt.parentNode !== this.tgtParent &&\r\n           ! (tgt && DomUtils.elementContains(lastKeptTgt.parentNode, tgt))) {\r\n      // Last-kept nodes are inside parents that are not\r\n      // parents of the newly matched nodes.  Must finish\r\n      // replacing their contents and back out.\r\n      this._replaceNodes(lastKeptTgt, null, lastKeptSrc, null);\r\n      lastKeptTgt = lastKeptTgt.parentNode;\r\n      lastKeptSrc = lastKeptSrc.parentNode;\r\n    }\r\n\r\n    // update instance vars; there's no going back inside these nodes\r\n    this.lastKeptTgtNode = lastKeptTgt;\r\n    this.lastKeptSrcNode = lastKeptSrc;\r\n\r\n    // Make sure same number of levels of \"moving up\" are\r\n    // appropriate for src as well, i.e. we aren't trying\r\n    // to match <c> in (<a><b/><c/></a>, <a><b/></a><a><c/></a>)\r\n    // after matching <b>, or vice versa.  In other words,\r\n    // if tag names and depths match, but identities of parents\r\n    // are inconsistent relative to previous matches, we catch it\r\n    // here.  In the example, lastKeptTgt would be the <b/> node\r\n    // on the left, which is not sibling of <c/> or of an ancestor\r\n    // of <c/> on the right.  If the example were reversed,\r\n    // lastKeptTgt would be the first <a> node, which is an\r\n    // ancestor of <c/> on the left rather than a sibling of an\r\n    // ancestor.\r\n    if (! finishing &&\r\n        (DomUtils.elementContains(lastKeptSrc, src) ||\r\n         ! (lastKeptSrc.parentNode === this.srcParent ||\r\n            DomUtils.elementContains(lastKeptSrc.parentNode, src)))) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (finishing) {\r\n    this._replaceNodes(lastKeptTgt, null, lastKeptSrc, null,\r\n                       this.tgtParent, this.srcParent);\r\n  } else {\r\n    // Compare tag names and depths to make sure we can match nodes...\r\n    if (! onlyAdvance) {\r\n      if (tgt.nodeName !== src.nodeName)\r\n        return false;\r\n    }\r\n\r\n    // Look at tags of parents until we hit parent of last-kept,\r\n    // which we know is ok.\r\n    for(var a=tgt.parentNode, b=src.parentNode;\r\n        a !== (starting ? this.tgtParent : lastKeptTgt.parentNode);\r\n        a = a.parentNode, b = b.parentNode) {\r\n      if (b === (starting ? this.srcParent : lastKeptSrc.parentNode))\r\n        return false; // src is shallower, b hit top first\r\n      if (a.nodeName !== b.nodeName)\r\n        return false; // tag names don't match\r\n    }\r\n    if (b !== (starting ? this.srcParent : lastKeptSrc.parentNode)) {\r\n      return false; // src is deeper, b didn't hit top when a did\r\n    }\r\n\r\n    var firstIter = true;\r\n    // move tgt and src backwards and out, replacing as we go\r\n    while (true) {\r\n      if (! (firstIter && onlyAdvance)) {\r\n        if (tgt.nodeType === 1) /* ELEMENT */\r\n          Patcher._copyAttributes(tgt, src);\r\n        if (copyCallback)\r\n          copyCallback(tgt, src);\r\n      }\r\n\r\n      firstIter = false;\r\n\r\n      if ((starting ? this.tgtParent : lastKeptTgt.parentNode)\r\n          === tgt.parentNode) {\r\n        // we've worked our way up to the same level as the last-kept nodes\r\n        this._replaceNodes(lastKeptTgt, tgt, lastKeptSrc, src);\r\n        break;\r\n      } else {\r\n        this._replaceNodes(null, tgt, null, src);\r\n        // move up to keep (match) parents as well\r\n        tgt = tgt.parentNode;\r\n        src = src.parentNode;\r\n      }\r\n    }\r\n  }\r\n\r\n  this.lastKeptTgtNode = tgtNode;\r\n  this.lastKeptSrcNode = srcNode;\r\n\r\n  return true;\r\n};\r\n\r\n// After a match, skip ahead to later siblings of the last kept nodes,\r\n// without performing any replacements.\r\nPatcher.prototype.skipToSiblings = function(tgt, src) {\r\n  var lastTgt = this.lastKeptTgtNode;\r\n  var lastSrc = this.lastKeptSrcNode;\r\n\r\n  if (! (lastTgt && lastTgt.parentNode === tgt.parentNode))\r\n    return false;\r\n\r\n  if (! (lastSrc && lastSrc.parentNode === src.parentNode))\r\n    return false;\r\n\r\n  this.lastKeptTgtNode = tgt;\r\n  this.lastKeptSrcNode = src;\r\n\r\n  return true;\r\n};\r\n\r\n// Completes patching assuming no more matches.\r\n//\r\n// Patchers are single-use, so no more methods can be called\r\n// on the Patcher.\r\nPatcher.prototype.finish = function() {\r\n  return this.match(null, null);\r\n};\r\n\r\n// Replaces the siblings between tgtBefore and tgtAfter (exclusive on both\r\n// sides) with the siblings between srcBefore and srcAfter (exclusive on both\r\n// sides).  Falsy values indicate start or end of siblings as appropriate.\r\n//\r\n// Precondition: tgtBefore and tgtAfter have same parent; either may be falsy,\r\n// but not both, unless optTgtParent is provided.  Same with srcBefore/srcAfter.\r\nPatcher.prototype._replaceNodes = function(\r\n  tgtBefore, tgtAfter, srcBefore, srcAfter, optTgtParent, optSrcParent)\r\n{\r\n  var tgtParent = optTgtParent || (tgtBefore || tgtAfter).parentNode;\r\n  var srcParent = optSrcParent || (srcBefore || srcAfter).parentNode;\r\n\r\n  // deal with case where top level is a range\r\n  if (tgtParent === this.tgtParent) {\r\n    tgtBefore = tgtBefore || this.tgtBefore;\r\n    tgtAfter = tgtAfter || this.tgtAfter;\r\n  }\r\n  if (srcParent === this.srcParent) {\r\n    srcBefore = srcBefore || this.srcBefore;\r\n    srcAfter = srcAfter || this.srcAfter;\r\n  }\r\n\r\n\r\n  // remove old children\r\n  var n;\r\n  while ((n = tgtBefore ? tgtBefore.nextSibling : tgtParent.firstChild)\r\n         && n !== tgtAfter) {\r\n    tgtParent.removeChild(n);\r\n  }\r\n\r\n  // add new children\r\n  var m;\r\n  while ((m = srcBefore ? srcBefore.nextSibling : srcParent.firstChild)\r\n         && m !== srcAfter) {\r\n    tgtParent.insertBefore(m, tgtAfter || null);\r\n  }\r\n};\r\n\r\n// Copy HTML attributes of node `src` onto node `tgt`.\r\n//\r\n// The effect we are trying to achieve is best expresed in terms of\r\n// HTML.  Whatever HTML generated `tgt`, we want to mutate the DOM element\r\n// so that it is as if it were the HTML that generated `src`.\r\n// We want to preserve JavaScript properties in general (tgt.foo),\r\n// while syncing the HTML attributes (tgt.getAttribute(\"foo\")).\r\n//\r\n// This is complicated by form controls and the fact that old IE\r\n// can't keep the difference straight between properties and attributes.\r\nPatcher._copyAttributes = function(tgt, src) {\r\n  var srcAttrs = src.attributes;\r\n  var tgtAttrs = tgt.attributes;\r\n\r\n  // Determine whether tgt has focus; works in all browsers\r\n  // as of FF3, Safari4\r\n  var targetFocused = (tgt === document.activeElement);\r\n\r\n  ///// Clear current attributes\r\n\r\n  if (tgt.style.cssText)\r\n    tgt.style.cssText = '';\r\n\r\n  var isRadio = false;\r\n  var finalChecked = null;\r\n  if (tgt.nodeName === \"INPUT\") {\r\n    // Record for later whether this is a radio button.\r\n    isRadio = (tgt.type === 'radio');\r\n\r\n    // Figure out whether this should be checked or not. If the re-rendering\r\n    // changed its idea of checkedness, go with that; otherwsie go with whatever\r\n    // the control's current setting is.\r\n    if (isRadio || tgt.type === 'checkbox') {\r\n      var tgtOriginalChecked = !!tgt._sparkOriginalRenderedChecked &&\r\n            tgt._sparkOriginalRenderedChecked[0];\r\n      var srcOriginalChecked = !!src._sparkOriginalRenderedChecked &&\r\n            src._sparkOriginalRenderedChecked[0];\r\n      // For radio buttons, we previously saved the checkedness in an expando\r\n      // property before doing some DOM operations that could wipe it out. For\r\n      // checkboxes, we can just use the checked property directly.\r\n      var tgtCurrentChecked = tgt._currentChecked ?\r\n            tgt._currentChecked[0] : tgt.checked;\r\n      if (tgtOriginalChecked === srcOriginalChecked) {\r\n        finalChecked = tgtCurrentChecked;\r\n      } else {\r\n        finalChecked = srcOriginalChecked;\r\n        tgt._sparkOriginalRenderedChecked = [finalChecked];\r\n      }\r\n    }\r\n  }\r\n\r\n  for(var i=tgtAttrs.length-1; i>=0; i--) {\r\n    var attr = tgtAttrs[i];\r\n    // In old IE, attributes that are possible on a node\r\n    // but not actually present will show up in this loop\r\n    // with specified=false.  All other browsers support\r\n    // 'specified' (because it's part of the spec) and\r\n    // set it to true.\r\n    if (! attr.specified)\r\n      continue;\r\n    var name = attr.name;\r\n    // Filter out attributes that are indexable by number\r\n    // but not by name.  This kills the weird \"propdescname\"\r\n    // attribute in IE 8.\r\n    if (! tgtAttrs[name])\r\n      continue;\r\n    // Some properties don't mutate well, and we simply\r\n    // don't try to patch them.  For example, you can't\r\n    // change a control's type in IE.\r\n    if (name === \"id\" || name === \"type\")\r\n      continue;\r\n    // Removing a radio button's \"name\" property and restoring\r\n    // it is harmless in most browsers but breaks in IE 7.\r\n    // It seems unlikely enough that a radio button will\r\n    // sometimes have a group and sometimes not.\r\n    if (isRadio && name === \"name\")\r\n      continue;\r\n    // Never delete the \"value\" attribute: we have special three-way diff logic\r\n    // for it at the end.\r\n    if (name === \"value\")\r\n      continue;\r\n    // Removing 'src' (e.g. in an iframe) can only be bad.\r\n    if (name === \"src\")\r\n      continue;\r\n\r\n    // We want to patch any HTML attributes that were specified in the\r\n    // source, but preserve DOM properties set programmatically.\r\n    // Old IE makes this difficult by exposing properties as attributes.\r\n    // Expando properties will even appear in innerHTML, though not if the\r\n    // value is an object rather than a primitive.\r\n    //\r\n    // We use a heuristic to determine if we are looking at a programmatic\r\n    // property (an expando) rather than a DOM attribute.\r\n    //\r\n    // Losing jQuery's expando (whose value is a number) is very bad,\r\n    // because it points to event handlers that only jQuery can detach,\r\n    // and only if the expando is in place.\r\n    var possibleExpando = tgt[name];\r\n    if (possibleExpando &&\r\n        (typeof possibleExpando === \"object\" ||\r\n         /^jQuery/.test(name)))\r\n      continue; // for object properties that surface attributes only in IE\r\n    tgt.removeAttributeNode(attr);\r\n  }\r\n\r\n  ///// Copy over src's attributes\r\n\r\n  if (tgt.mergeAttributes) {\r\n    // IE code path:\r\n    //\r\n    // Only IE (all versions) has mergeAttributes.\r\n    // It's probably a good bit faster in old IE than\r\n    // iterating over all the attributes, and the treatment\r\n    // of form controls is sufficiently different in IE from\r\n    // other browsers that we keep the special cases separate.\r\n\r\n    // Don't copy _sparkOriginalRenderedValue, though.\r\n    var srcExpando = src._sparkOriginalRenderedValue;\r\n    src.removeAttribute('_sparkOriginalRenderedValue');\r\n\r\n    tgt.mergeAttributes(src);\r\n    if (srcExpando)\r\n      src._sparkOriginalRenderedValue = srcExpando;\r\n\r\n    if (src.name)\r\n      tgt.name = src.name;\r\n\r\n  } else {\r\n    // Non-IE code path:\r\n\r\n    for(var i=0, L=srcAttrs.length; i<L; i++) {\r\n      var srcA = srcAttrs.item(i);\r\n      if (srcA.specified) {\r\n        var name = srcA.name.toLowerCase();\r\n        var value = String(srcA.value);\r\n        if (name === \"type\") {\r\n        // can't change type of INPUT in IE; don't support it\r\n        } else if (name === \"checked\") {\r\n          // handled specially below\r\n        } else if (name === \"style\") {\r\n          tgt.style.cssText = src.style.cssText;\r\n        } else if (name === \"class\") {\r\n          tgt.className = src.className;\r\n        } else if (name === \"value\") {\r\n          // don't set attribute, just overwrite property\r\n          // (in next phase)\r\n        } else if (name === \"src\") {\r\n          // only set if different.  protects iframes\r\n          if (src.src !== tgt.src)\r\n            tgt.src = src.src;\r\n        } else {\r\n          try {\r\n            tgt.setAttribute(name, value);\r\n          } catch (e) {\r\n            throw new Error(\"Error copying attribute '\" + name + \"': \" + e);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  var originalRenderedValue = function (node) {\r\n    if (!node._sparkOriginalRenderedValue)\r\n      return null;\r\n    return node._sparkOriginalRenderedValue[0];\r\n  };\r\n  var srcOriginalRenderedValue = originalRenderedValue(src);\r\n  var tgtOriginalRenderedValue = originalRenderedValue(tgt);\r\n\r\n  // Save the target's current value.\r\n  var tgtCurrentValue = DomUtils.getElementValue(tgt);\r\n\r\n  if (tgt.nodeName === \"SELECT\") {\r\n    // Copy over the descendents of the tag (eg, OPTIONs, OPTGROUPs, etc) so\r\n    // that we get the new version's OPTIONs. (We don't look for any more nested\r\n    // preserved regions inside the element.)\r\n    while (tgt.firstChild)\r\n      tgt.removeChild(tgt.firstChild);\r\n    while (src.firstChild)\r\n      tgt.insertBefore(src.firstChild, null);\r\n    // ... but preserve the original <SELECT>'s value if possible (ie, ignore\r\n    // any <OPTION SELECTED>s that we may have copied over).\r\n    DomUtils.setElementValue(tgt, tgtCurrentValue);\r\n  }\r\n\r\n  // We preserve the old element's value unless both of the following are true:\r\n  //   - The newly rendered value is different from the old rendered value: ie,\r\n  //     something has actually changed on the server.\r\n  //   - It's unfocused. If it's focused, the user might be editing it, and\r\n  //     we don't want to update what the user is currently editing (and lose\r\n  //     the selection, etc).\r\n  //\r\n  // After updating the element's value, we update its\r\n  // _sparkOriginalRenderedValue to match.\r\n  //\r\n  // There's a case where we choose to update _sparkOriginalRenderedValue even\r\n  // though we're not updating the visible value. That's when the element is\r\n  // focused (preventing us from updating the visible value), but the newly\r\n  // rendered value matches the visible value. In this case, updating the\r\n  // visible value would have been a no-op, so we can do the matching\r\n  // _sparkOriginalRenderedValue update.\r\n  //\r\n  // Note that we expect src._sparkOriginalRenderedValue[0] to be equal to\r\n  // src.value. For <LI>'s, though, there is a value property (the ordinal in\r\n  // the list) even though there is no value attribute (and thus no saved\r\n  // _sparkOriginalRenderedValue), so we do have to be sure to do the comparison\r\n  // with src._sparkOriginalRenderedValue[0] rather than with src.value.\r\n  if (srcOriginalRenderedValue !== tgtOriginalRenderedValue &&\r\n      (tgtCurrentValue === srcOriginalRenderedValue || !targetFocused)) {\r\n    // Update the on-screen value to the newly rendered value, but only if it's\r\n    // an actual change (a seemingly \"no-op\" value update resets the selection,\r\n    // so don't do that!)\r\n    if (tgtCurrentValue !== srcOriginalRenderedValue)\r\n      DomUtils.setElementValue(tgt, srcOriginalRenderedValue);\r\n    // ... and overwrite the saved rendered value too, so that the next time\r\n    // around we'll be comparing to this rendered value instead of the old one.\r\n    tgt._sparkOriginalRenderedValue = [srcOriginalRenderedValue];\r\n  }\r\n\r\n  // Deal with checkboxes and radios.\r\n  if (finalChecked !== null) {\r\n    // Don't do a no-op write to 'checked', since in some browsers that triggers\r\n    // events.\r\n    if (tgt.checked !== finalChecked)\r\n      tgt.checked = finalChecked;\r\n\r\n    // Set various other fields related to checkedness.\r\n    tgt.defaultChecked = finalChecked;\r\n    if (finalChecked)\r\n      tgt.setAttribute(\"checked\", \"checked\");\r\n    else\r\n      tgt.removeAttribute(\"checked\");\r\n  }\r\n};\r\n\r\nSparkTest.Patcher = Patcher;\r\n","Meteor.render = function (htmlFunc) {\r\n  return Spark.render(function () {\r\n    return Spark.isolate(\r\n      typeof htmlFunc === 'function' ? htmlFunc : function() {\r\n        // non-function argument becomes a constant (non-reactive) string\r\n        return String(htmlFunc);\r\n      });\r\n  });\r\n};\r\n\r\nMeteor.renderList = function (cursor, itemFunc, elseFunc) {\r\n  return Spark.render(function () {\r\n    return Spark.list(cursor, function (item) {\r\n      var label = item._id ? idStringify(item._id) : null;\r\n      return Spark.labelBranch(label, function () {\r\n        return Spark.isolate(_.bind(itemFunc, null, item));\r\n      });\r\n    }, function () {\r\n      return elseFunc ? Spark.isolate(elseFunc) : '';\r\n    });\r\n  });\r\n};\r\n","Spark._labelFromIdOrName = function(n) {\r\n  var label = null;\r\n\r\n  if (n.nodeType === 1 /*ELEMENT_NODE*/) {\r\n    if (n.getAttribute('id')) {\r\n      label = '#' + n.getAttribute('id');\r\n    } else if (n.getAttribute(\"name\")) {\r\n      label = n.getAttribute(\"name\");\r\n      // Radio button special case:  radio buttons\r\n      // in a group all have the same name.  Their value\r\n      // determines their identity.\r\n      // Checkboxes with the same name and different\r\n      // values are also sometimes used in apps, so\r\n      // we treat them similarly.\r\n      if (n.nodeName === 'INPUT' &&\r\n          (n.type === 'radio' || n.type === 'checkbox') &&\r\n          n.value)\r\n        label = label + ':' + n.value;\r\n\r\n      // include parent names and IDs up to enclosing ID\r\n      // in the label\r\n      while (n.parentNode &&\r\n             n.parentNode.nodeType === 1 /*ELEMENT_NODE*/) {\r\n        n = n.parentNode;\r\n        if (n.id) {\r\n          label = '#' + n.id + \"/\" + label;\r\n          break;\r\n        } else if (n.getAttribute('name')) {\r\n          label = n.getAttribute('name') + \"/\" + label;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return label;\r\n};\r\n"]}