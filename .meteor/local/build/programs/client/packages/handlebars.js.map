)]}'
{"version":3,"file":"\\packages\\handlebars.js","sources":["handlebars/evaluate-handlebars.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gB;;AAEA,qE;AACA,yC;;AAEA,wD;AACA,wC;;AAEA,8C;AACA,mC;AACA,mD;AACA,I;AACA,E;;AAEA,+E;AACA,8E;AACA,kC;AACA,mC;AACA,kD;AACA,iC;;AAEA,sB;AACA,yD;AACA,kB;AACA,E;AACA,uB;AACA,gC;AACA,E;AACA,mC;;AAEA,mE;AACA,2D;AACA,iE;AACA,oE;AACA,yC;AACA,+B;AACA,oC;AACA,yD;AACA,mC;AACA,Q;AACA,8B;AACA,I;AACA,oC;AACA,0B;AACA,gC;AACA,yC;AACA,2C;AACA,2D;AACA,2D;AACA,0C;AACA,qD;AACA,+B;AACA,W;AACA,kB;AACA,Q;AACA,+B;AACA,e;AACA,qB;AACA,6C;AACA,W;AACA,I;AACA,kC;AACA,yD;AACA,mC;AACA,Q;AACA,8B;AACA,I;AACA,sC;AACA,yD;AACA,8B;AACA,Q;AACA,mC;AACA,G;AACA,E;;AAEA,mD;AACA,0C;AACA,gE;AACA,2C;AACA,E;;AAEA,mC;AACA,kC;AACA,oB;AACA,gB;AACA,gB;AACA,kB;AACA,kB;AACA,kE;AACA,gB;AACA,I;AACA,gC;AACA,yB;AACA,I;;AAEA,uB;AACA,8C;AACA,I;AACA,K;;AAEA,oF;AACA,0D;;AAEA,qD;AACA,0B;AACA,0D;AACA,2C;AACA,wC;;AAEA,sE;AACA,2D;AACA,oE;AACA,mE;AACA,mE;AACA,kE;AACA,qE;AACA,yB;;AAEA,yC;AACA,gC;AACA,gB;;AAEA,uC;AACA,qC;AACA,wB;AACA,kD;AACA,U;AACA,6B;AACA,K;;AAEA,wB;AACA,6C;AACA,wB;;AAEA,gC;AACA,uB;AACA,2D;AACA,8D;AACA,sB;AACA,uC;AACA,6B;AACA,K;;AAEA,iE;AACA,4D;AACA,iE;AACA,gE;AACA,oD;AACA,8B;;AAEA,a;AACA,4E;AACA,uC;AACA,4B;AACA,Y;AACA,uC;AACA,4D;AACA,8B;AACA,iE;AACA,qE;AACA,iE;AACA,yE;AACA,sE;AACA,wC;AACA,mE;AACA,mE;AACA,4E;AACA,O;AACA,uD;AACA,+C;AACA,K;;AAEA,qC;AACA,yC;AACA,uD;AACA,sC;AACA,Q;AACA,gE;AACA,0B;AACA,4B;AACA,6B;AACA,gC;AACA,Q;AACA,uD;AACA,2D;AACA,wD;AACA,uD;AACA,gC;AACA,uC;AACA,mC;AACA,wB;AACA,O;AACA,gD;AACA,sD;AACA,0D;AACA,kB;AACA,c;AACA,O;;AAEA,yB;AACA,K;;AAEA,2D;AACA,uD;AACA,wD;AACA,+C;AACA,mC;AACA,oC;;AAEA,gB;AACA,I;;AAEA,iD;AACA,wD;AACA,0D;AACA,+C;AACA,0D;AACA,wB;AACA,6B;;AAEA,yD;AACA,qC;AACA,yC;AACA,kB;AACA,gE;AACA,6D;AACA,wB;AACA,0C;AACA,0C;AACA,qE;AACA,S;AACA,K;;AAEA,0C;AACA,iC;AACA,sC;AACA,0C;AACA,oE;AACA,gB;AACA,yB;AACA,+C;AACA,M;;AAEA,0C;AACA,sC;AACA,+C;;AAEA,yC;AACA,uB;;AAEA,wC;AACA,sD;AACA,2B;AACA,6B;AACA,uC;AACA,0C;AACA,8D;AACA,qD;AACA,mC;AACA,yD;AACA,sB;AACA,Y;AACA,wB;AACA,K;;AAEA,gC;AACA,I;;AAEA,oD;AACA,iB;;AAEA,iC;AACA,0C;AACA,kD;AACA,oC;AACA,qC;AACA,0B;AACA,M;;AAEA,0E;AACA,0E;AACA,6B;AACA,kD;AACA,6B;AACA,8D;AACA,qE;AACA,uB;AACA,iD;AACA,kD;AACA,0B;AACA,Y;AACA,sD;AACA,Q;AACA,M;;AAEA,+C;AACA,e;AACA,4B;AACA,6D;AACA,yD;AACA,mC;AACA,6C;AACA,4B;AACA,6C;AACA,M;;AAEA,iB;AACA,sD;AACA,+D;AACA,iE;AACA,4D;AACA,+B;AACA,yD;AACA,M;AACA,uC;AACA,mE;AACA,sE;AACA,iE;AACA,mE;AACA,8D;AACA,M;;AAEA,wC;AACA,uB;AACA,mC;AACA,sB;AACA,8B;AACA,4B;AACA,6C;AACA,oD;AACA,Y;AACA,8B;AACA,8B;AACA,6C;AACA,uD;AACA,Y;AACA,gC;AACA,4B;AACA,+B;AACA,oC;AACA,2B;AACA,wE;AACA,yB;AACA,yB;AACA,wC;AACA,2B;AACA,8E;AACA,yB;AACA,+C;AACA,8D;AACA,W;AACA,uB;AACA,kC;AACA,wB;AACA,iC;AACA,uC;AACA,6E;AACA,oE;AACA,2B;AACA,oD;AACA,6D;AACA,W;AACA,uB;AACA,Y;AACA,mD;AACA,O;;AAEA,wB;AACA,I;;AAEA,qE;AACA,uC;AACA,yE;AACA,mE;AACA,yC;;AAEA,8D;AACA,E;;AAEA,0C;AACA,uB;AACA,E;AACA,uD;AACA,gC;AACA,E","sourcesContent":["Handlebars = {};\r\n\r\n// XXX we probably forgot to implement the #foo case where foo is not\r\n// a helper (and similarly the ^foo case)\r\n\r\n// XXX there is a ton of stuff that needs testing! like,\r\n// everything. including the '..' stuff.\r\n\r\nHandlebars.json_ast_to_func = function (ast) {\r\n  return function (data, options) {\r\n    return Handlebars.evaluate(ast, data, options);\r\n  };\r\n};\r\n\r\n// If minimongo is available (it's a weak dependency) use its ID stringifier to\r\n// label branches (so that, eg, ObjectId and strings don't overlap). Otherwise\r\n// just use the identity function.\r\nvar idStringify = Package.minimongo\r\n  ? Package.minimongo.LocalCollection._idStringify\r\n  : function (id) { return id; };\r\n\r\n// block helpers take:\r\n// (N args), options (hash args, plus 'fn' and 'inverse')\r\n// and return text\r\n//\r\n// normal helpers take:\r\n// (N args), options (hash args)\r\n//\r\n// partials take one argument, data\r\n\r\n// XXX handlebars' format for arguments is not the clearest, likely\r\n// for backwards compatibility to mustache. eg, options ===\r\n// options.fn. take the opportunity to clean this up. treat block\r\n// arguments (fn, inverse) as just another kind of argument, same as\r\n// what is passed in via named arguments.\r\nHandlebars._default_helpers = {\r\n  'with': function (data, options) {\r\n    if (!data || (data instanceof Array && !data.length))\r\n      return options.inverse(this);\r\n    else\r\n      return options.fn(data);\r\n  },\r\n  'each': function (data, options) {\r\n    var parentData = this;\r\n    if (data && data.length > 0)\r\n      return _.map(data, function(x, i) {\r\n        // infer a branch key from the data\r\n        var branch = ((x && x._id && idStringify(x._id)) ||\r\n                      (typeof x === 'string' ? x : null) ||\r\n                      Spark.UNIQUE_LABEL);\r\n        return Spark.labelBranch(branch, function() {\r\n          return options.fn(x);\r\n        });\r\n      }).join('');\r\n    else\r\n      return Spark.labelBranch(\r\n        'else',\r\n        function () {\r\n          return options.inverse(parentData);\r\n        });\r\n  },\r\n  'if': function (data, options) {\r\n    if (!data || (data instanceof Array && !data.length))\r\n      return options.inverse(this);\r\n    else\r\n      return options.fn(this);\r\n  },\r\n  'unless': function (data, options) {\r\n    if (!data || (data instanceof Array && !data.length))\r\n      return options.fn(this);\r\n    else\r\n      return options.inverse(this);\r\n  }\r\n};\r\n\r\nHandlebars.registerHelper = function (name, func) {\r\n  if (name in Handlebars._default_helpers)\r\n    throw new Error(\"There is already a helper '\" + name + \"'\");\r\n  Handlebars._default_helpers[name] = func;\r\n};\r\n\r\n// Utility to HTML-escape a string.\r\nHandlebars._escape = (function() {\r\n  var escape_map = {\r\n    \"<\": \"&lt;\",\r\n    \">\": \"&gt;\",\r\n    '\"': \"&quot;\",\r\n    \"'\": \"&#x27;\",\r\n    \"`\": \"&#x60;\", /* IE allows backtick-delimited attributes?? */\r\n    \"&\": \"&amp;\"\r\n  };\r\n  var escape_one = function(c) {\r\n    return escape_map[c];\r\n  };\r\n\r\n  return function (x) {\r\n    return x.replace(/[&<>\"'`]/g, escape_one);\r\n  };\r\n})();\r\n\r\n// be able to recognize default \"this\", which is different in different environments\r\nHandlebars._defaultThis = (function() { return this; })();\r\n\r\nHandlebars.evaluate = function (ast, data, options) {\r\n  options = options || {};\r\n  var helpers = _.extend({}, Handlebars._default_helpers);\r\n  _.extend(helpers, options.helpers || {});\r\n  var partials = options.partials || {};\r\n\r\n  // re 'stack' arguments: top of stack is the current data to use for\r\n  // the template. higher levels are the data referenced by\r\n  // identifiers with one or more '..' segments. we have to keep the\r\n  // stack pure-functional style, with a tree rather than an array,\r\n  // because we want to continue to allow block helpers provided by\r\n  // the user to capture their subtemplate rendering functions and\r\n  // call them later, after we've finished running (for eg findLive.)\r\n  // maybe revisit later.\r\n\r\n  var eval_value = function (stack, id) {\r\n    if (typeof(id) !== \"object\")\r\n      return id;\r\n\r\n    // follow '..' in {{../../foo.bar}}\r\n    for (var i = 0; i < id[0]; i++) {\r\n      if (!stack.parent)\r\n        throw new Error(\"Too many '..' segments\");\r\n      else\r\n        stack = stack.parent;\r\n    }\r\n\r\n    if (id.length === 1)\r\n      // no name: {{this}}, {{..}}, {{../..}}\r\n      return stack.data;\r\n\r\n    var scopedToContext = false;\r\n    if (id[1] === '') {\r\n      // an empty path segment is our AST's way of encoding\r\n      // the presence of 'this.' at the beginning of the path.\r\n      id = id.slice();\r\n      id.splice(1, 1); // remove the ''\r\n      scopedToContext = true;\r\n    }\r\n\r\n    // when calling functions (helpers/methods/getters), dataThis\r\n    // tracks what to use for `this`.  For helpers, it's the\r\n    // current data context.  For getters and methods on the data\r\n    // context object, and on the return value of a helper, it's\r\n    // the object where we got the getter or method.\r\n    var dataThis = stack.data;\r\n\r\n    var data;\r\n    if (id[0] === 0 && helpers.hasOwnProperty(id[1]) && ! scopedToContext) {\r\n      // first path segment is a helper\r\n      data = helpers[id[1]];\r\n    } else {\r\n      if ((! data instanceof Object) &&\r\n          (typeof (function() {})[id[1]] !== 'undefined') &&\r\n          ! scopedToContext) {\r\n        // Give a helpful error message if the user tried to name\r\n        // a helper 'name', 'length', or some other built-in property\r\n        // of function objects.  Unfortunately, this case is very\r\n        // hard to detect, as Template.foo.name = ... will fail silently,\r\n        // and {{name}} will be silently empty if the property doesn't\r\n        // exist (per Handlebars rules).\r\n        // However, if there is no data context at all, we jump in.\r\n        throw new Error(\"Can't call a helper '\"+id[1]+\"' because \"+\r\n                        \"it is a built-in function property in JavaScript\");\r\n      }\r\n      // first path segment is property of data context\r\n      data = (stack.data && stack.data[id[1]]);\r\n    }\r\n\r\n    // handle dots, as in {{foo.bar}}\r\n    for (var i = 2; i < id.length; i++) {\r\n      // Call functions when taking the dot, to support\r\n      // for example currentUser.name.\r\n      //\r\n      // In the case of {{foo.bar}}, we end up returning one of:\r\n      // - helpers.foo.bar\r\n      // - helpers.foo().bar\r\n      // - stack.data.foo.bar\r\n      // - stack.data.foo().bar.\r\n      //\r\n      // The caller does the final application with any\r\n      // arguments, as in {{foo.bar arg1 arg2}}, and passes\r\n      // the current data context in `this`.  Therefore,\r\n      // we use the current data context (`helperThis`)\r\n      // for all function calls.\r\n      if (typeof data === 'function') {\r\n        data = data.call(dataThis);\r\n        dataThis = data;\r\n      }\r\n      if (data === undefined || data === null) {\r\n        // Handlebars fails silently and returns \"\" if\r\n        // we start to access properties that don't exist.\r\n        data = '';\r\n        break;\r\n      }\r\n\r\n      data = data[id[i]];\r\n    }\r\n\r\n    // ensure `this` is bound appropriately when the caller\r\n    // invokes `data` with any arguments.  For example,\r\n    // in {{foo.bar baz}}, the caller must supply `baz`,\r\n    // but we alone have `foo` (in `dataThis`).\r\n    if (typeof data === 'function')\r\n      return _.bind(data, dataThis);\r\n\r\n    return data;\r\n  };\r\n\r\n  // 'extra' will be clobbered, but not 'params'.\r\n  // if (isNested), evaluate params.slice(1) as a nested\r\n  // helper invocation if there is at least one positional\r\n  // argument.  This is used for block helpers.\r\n  var invoke = function (stack, params, extra, isNested) {\r\n    extra = extra || {};\r\n    params = params.slice(0);\r\n\r\n    // remove hash (dictionary of keyword arguments) from\r\n    // the end of params, if present.\r\n    var last = params[params.length - 1];\r\n    var hash = {};\r\n    if (typeof(last) === \"object\" && !(last instanceof Array)) {\r\n      // evaluate hash values, which are found as invocations\r\n      // like [0, \"foo\"]\r\n      _.each(params.pop(), function(v,k) {\r\n        var result = eval_value(stack, v);\r\n        hash[k] = (typeof result === \"function\" ? result() : result);\r\n      });\r\n    }\r\n\r\n    var apply = function (values, extra) {\r\n      var args = values.slice(1);\r\n      for(var i=0; i<args.length; i++)\r\n        if (typeof args[i] === \"function\")\r\n          args[i] = args[i](); // `this` already bound by eval_value\r\n      if (extra)\r\n        args.push(extra);\r\n      return values[0].apply(stack.data, args);\r\n    };\r\n\r\n    var values = new Array(params.length);\r\n    for(var i=0; i<params.length; i++)\r\n      values[i] = eval_value(stack, params[i]);\r\n\r\n    if (typeof(values[0]) !== \"function\")\r\n      return values[0];\r\n\r\n    if (isNested && values.length > 1) {\r\n      // at least one positional argument; not no args\r\n      // or only hash args.\r\n      var oneArg = values[1];\r\n      if (typeof oneArg === \"function\")\r\n        // invoke the positional arguments\r\n        // (and hash arguments) as a nested helper invocation.\r\n        oneArg = apply(values.slice(1), {hash:hash});\r\n      values = [values[0], oneArg];\r\n      // keyword args don't go to the block helper, then.\r\n      extra.hash = {};\r\n    } else {\r\n      extra.hash = hash;\r\n    }\r\n\r\n    return apply(values, extra);\r\n  };\r\n\r\n  var template = function (stack, elts, basePCKey) {\r\n    var buf = [];\r\n\r\n    var toString = function (x) {\r\n      if (typeof x === \"string\") return x;\r\n      // May want to revisit the following one day\r\n      if (x === null) return \"null\";\r\n      if (x === undefined) return \"\";\r\n      return x.toString();\r\n    };\r\n\r\n    // wrap `fn` and `inverse` blocks in chunks having `data`, if the data\r\n    // is different from the enclosing data, so that the data is available\r\n    // at runtime for events.\r\n    var decorateBlockFn = function(fn, old_data) {\r\n      return function(data) {\r\n        // don't create spurious annotations when data is same\r\n        // as before (or when transitioning between e.g. `window` and\r\n        // `undefined`)\r\n        if ((data || Handlebars._defaultThis) ===\r\n            (old_data || Handlebars._defaultThis))\r\n          return fn(data);\r\n        else\r\n          return Spark.setDataContext(data, fn(data));\r\n      };\r\n    };\r\n\r\n    // Handle the return value of a {{helper}}.\r\n    // Takes a:\r\n    //   string - escapes it\r\n    //   SafeString - returns the underlying string unescaped\r\n    //   other value - coerces to a string and escapes it\r\n    var maybeEscape = function(x) {\r\n      if (x instanceof Handlebars.SafeString)\r\n        return x.toString();\r\n      return Handlebars._escape(toString(x));\r\n    };\r\n\r\n    var curIndex;\r\n    // Construct a unique key for the current position\r\n    // in the AST.  Since template(...) is invoked recursively,\r\n    // the \"PC\" (program counter) key is hierarchical, consisting\r\n    // of one or more numbers, for example '0' or '1.3.0.1'.\r\n    var getPCKey = function() {\r\n      return (basePCKey ? basePCKey+'.' : '') + curIndex;\r\n    };\r\n    var branch = function(name, func) {\r\n      // Construct a unique branch identifier based on what partial\r\n      // we're in, what partial or helper we're calling, and our index\r\n      // into the template AST (essentially the program counter).\r\n      // If \"foo\" calls \"bar\" at index 3, it looks like: bar@foo#3.\r\n      return Spark.labelBranch(name + \"@\" + getPCKey(), func);\r\n    };\r\n\r\n    _.each(elts, function (elt, index) {\r\n      curIndex = index;\r\n      if (typeof(elt) === \"string\")\r\n        buf.push(elt);\r\n      else if (elt[0] === '{')\r\n        // {{double stache}}\r\n        buf.push(branch(elt[1], function () {\r\n          return maybeEscape(invoke(stack, elt[1]));\r\n        }));\r\n      else if (elt[0] === '!')\r\n        // {{{triple stache}}}\r\n        buf.push(branch(elt[1], function () {\r\n          return toString(invoke(stack, elt[1] || ''));\r\n        }));\r\n      else if (elt[0] === '#') {\r\n        // {{#block helper}}\r\n        var pcKey = getPCKey();\r\n        var block = decorateBlockFn(\r\n          function (data) {\r\n            return template({parent: stack, data: data}, elt[2], pcKey);\r\n          }, stack.data);\r\n        block.fn = block;\r\n        block.inverse = decorateBlockFn(\r\n          function (data) {\r\n            return template({parent: stack, data: data}, elt[3] || [], pcKey);\r\n          }, stack.data);\r\n        var html = branch(elt[1], function () {\r\n          return toString(invoke(stack, elt[1], block, true));\r\n        });\r\n        buf.push(html);\r\n      } else if (elt[0] === '>') {\r\n        // {{> partial}}\r\n        var partialName = elt[1];\r\n        if (!(partialName in partials))\r\n          // XXX why do we call these templates in docs and partials in code?\r\n          throw new Error(\"No such template '\" + partialName + \"'\");\r\n        // call the partial\r\n        var html = branch(partialName, function () {\r\n          return toString(partials[partialName](stack.data));\r\n        });\r\n        buf.push(html);\r\n      } else\r\n        throw new Error(\"bad element in template\");\r\n    });\r\n\r\n    return buf.join('');\r\n  };\r\n\r\n  // Set the prefix for PC keys, which identify call sites in the AST\r\n  // for the purpose of chunk matching.\r\n  // `options.name` will be null in the body, but otherwise have a value,\r\n  // assuming `options` was assembled in templating/deftemplate.js.\r\n  var rootPCKey = (options.name||\"\")+\"#\";\r\n\r\n  return template({data: data, parent: null}, ast, rootPCKey);\r\n};\r\n\r\nHandlebars.SafeString = function(string) {\r\n  this.string = string;\r\n};\r\nHandlebars.SafeString.prototype.toString = function() {\r\n  return this.string.toString();\r\n};\r\n"]}