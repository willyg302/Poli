{"version":3,"file":"\\packages\\handlebars.js","sources":["handlebars/parse-handlebars.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,gB;;AAEA,c;AACA,E;AACA,yD;AACA,6B;AACA,6C;AACA,+C;AACA,uC;AACA,8C;AACA,sC;AACA,8D;AACA,E;AACA,sE;AACA,qE;AACA,E;AACA,sB;AACA,6B;AACA,wE;AACA,kC;AACA,E;AACA,gE;AACA,E;AACA,oE;AACA,+D;AACA,Y;AACA,G;;AAEA,+B;AACA,sC;;AAEA,6B;AACA,kD;AACA,yB;AACA,W;AACA,qB;AACA,E;;AAEA,kE;AACA,qE;AACA,qB;;AAEA,gE;AACA,wB;AACA,E;AACA,0C;AACA,O;AACA,gC;AACA,e;AACA,gE;AACA,kE;AACA,oE;AACA,+D;AACA,oE;AACA,oE;AACA,8D;AACA,6B;AACA,oE;AACA,U;AACA,oE;;AAEA,kB;AACA,iD;;AAEA,Y;AACA,G;;AAEA,oE;AACA,2E;AACA,oC;;AAEA,oC;AACA,2B;AACA,uE;AACA,oE;AACA,6D;AACA,sE;AACA,c;AACA,2B;AACA,0E;AACA,4E;AACA,2E;AACA,oB;AACA,sC;AACA,mB;AACA,kC;AACA,I;;AAEA,+B;AACA,mE;AACA,qE;AACA,4B;AACA,2D;AACA,yB;AACA,4B;AACA,iC;AACA,K;;AAEA,mB;AACA,qD;AACA,oD;AACA,uD;AACA,+D;AACA,M;AACA,gC;AACA,kE;AACA,oC;AACA,I;;AAEA,8B;AACA,6B;AACA,iE;AACA,iB;AACA,qC;AACA,8B;AACA,O;AACA,e;AACA,I;;AAEA,oC;AACA,iC;AACA,uE;AACA,wB;AACA,kC;AACA,4B;AACA,kB;AACA,gC;AACA,e;AACA,I;;AAEA,mC;AACA,iB;;AAEA,e;AACA,gB;;AAEA,mB;AACA,iC;AACA,+D;AACA,Q;AACA,gC;AACA,qC;AACA,2C;AACA,gE;AACA,kD;AACA,yE;AACA,6B;AACA,yB;AACA,kE;AACA,oB;AACA,Q;AACA,8B;AACA,gD;AACA,oD;AACA,iC;AACA,4D;AACA,oB;AACA,Q;AACA,gC;AACA,iD;AACA,yC;AACA,kE;AACA,sD;AACA,Q;AACA,wD;AACA,iC;AACA,M;;AAEA,mC;AACA,kC;AACA,sE;AACA,+B;AACA,O;;AAEA,e;AACA,I;;AAEA,6B;AACA,kE;AACA,kC;AACA,E;;AAEA,mD;AACA,uC;AACA,2B;AACA,sE;AACA,iC;AACA,oD;AACA,I;AACA,0C;AACA,0D;AACA,E","sourcesContent":["Handlebars = {};\r\n\r\n/* Our format:\r\n *\r\n * A 'template' is an array. Each element in it is either\r\n * - a literal string to echo\r\n * - an escaped substition: ['{', invocation]\r\n * - an unescaped substition: ['!', invocation]\r\n * - a (conditional or iterated) block:\r\n *   ['#', invocation, template_a, template_b]\r\n *   (the second template is optional)\r\n * - a partial: ['>', partial_name] (partial_name is a string)\r\n *\r\n * An 'invocation' is an array: one or more 'values', then an optional\r\n * hash (of which the keys are strings, and the values are 'values'.)\r\n *\r\n * An 'identifier' is:\r\n * - [depth, key, key, key..]\r\n * Eg, '../../a.b.c' would be [2, 'a', 'b', 'c']. 'a' would be [0, 'a'].\r\n * And 'this' or '.' would be [0].\r\n *\r\n * A 'value' is either an identifier, or a string, int, or bool.\r\n *\r\n * You should provide a block helper 'with' since we will emit calls\r\n * to it (if the user passes the second 'context' argument to a\r\n * partial.)\r\n */\r\n\r\nvar path = Npm.require('path');\r\nvar hbars = Npm.require('handlebars');\r\n\r\n// Has keys 'message', 'line'\r\nHandlebars.ParseError = function (message, line) {\r\n  this.message = message;\r\n  if (line)\r\n    this.line = line;\r\n};\r\n\r\n// Raises Handlebars.ParseError if the Handlebars parser fails. We\r\n// will do our best to decode the output of Handlebars into a message\r\n// and a line number.\r\n\r\n// If Handlebars parsing fails, the Handlebars parser error will\r\n// escape to the caller.\r\n//\r\nHandlebars.to_json_ast = function (code) {\r\n  try {\r\n    var ast = hbars.parse(code);\r\n  } catch (e) {\r\n    // The Handlebars parser throws Error objects with a message\r\n    // attribute (and nothing else) and we must do our best. Parse\r\n    // errors include a line number (relative to the start of 'code'\r\n    // of course) which we'll attempt to parse out. (Handlebars\r\n    // almost, but not quite copies the line number information onto\r\n    // the Error object.) Other than parse errors, you also see very\r\n    // short strings like \"else doesn't match unless\" (with no\r\n    // location information.)\r\n    var m = e.message.match(/^Parse error on line (\\d+):([\\s\\S]*)$/)\r\n    if (m)\r\n      throw new Handlebars.ParseError(\"Parse error:\" + m[2], +m[1]);\r\n\r\n    if (e.message)\r\n      throw new Handlebars.ParseError(e.message);\r\n\r\n    throw e;\r\n  }\r\n\r\n  // Recreate Handlebars.Exception to properly report error messages\r\n  // and stack traces. (https://github.com/wycats/handlebars.js/issues/226)\r\n  makeHandlebarsExceptionsVisible();\r\n\r\n  var identifier = function (node) {\r\n    if (node.type !== \"ID\")\r\n      throw new Error(\"got ast node \" + node.type + \" for identifier\");\r\n    // drop node.isScoped. this is true if there was a 'this' or '.'\r\n    // anywhere in the path. vanilla handlebars will turn off\r\n    // helpers lookup if isScoped is true, but this is too restrictive\r\n    // for us.\r\n    var ret = [node.depth];\r\n    // we still want to turn off helper lookup if path starts with 'this.'\r\n    // as in {{this.foo}}, which means it has to look different from {{foo}}\r\n    // in our AST.  signal the presence of 'this' in our AST using an empty\r\n    // path segment.\r\n    if (/^this\\./.test(node.original))\r\n      ret.push('');\r\n    return ret.concat(node.parts);\r\n  };\r\n\r\n  var value = function (node) {\r\n    // Work around handlebars.js Issue #422 - Negative integers for\r\n    // helpers get trapped as ID. handlebars doesn't support floating\r\n    // point, just integers.\r\n    if (node.type === 'ID' && /^-\\d+$/.test(node.string)) {\r\n      // Reconstruct node\r\n      node.type = 'INTEGER';\r\n      node.integer = node.string;\r\n    }\r\n\r\n    var choices = {\r\n      ID: function (node) {return identifier(node);},\r\n      STRING: function (node) {return node.string;},\r\n      INTEGER: function (node) {return +node.integer;},\r\n      BOOLEAN: function (node) {return (node.bool === 'true');}\r\n    };\r\n    if (!(node.type in choices))\r\n      throw new Error(\"got ast node \" + node.type + \" for value\");\r\n    return choices[node.type](node);\r\n  };\r\n\r\n  var hash = function (node) {\r\n    if (node.type !== \"hash\")\r\n      throw new Error(\"got ast node \" + node.type + \" for hash\");\r\n    var ret = {};\r\n    _.each(node.pairs, function (p) {\r\n      ret[p[0]] = value(p[1]);\r\n    });\r\n    return ret;\r\n  };\r\n\r\n  var invocation = function (node) {\r\n    if (node.type !== \"mustache\")\r\n      throw new Error(\"got ast node \" + node.type + \" for invocation\");\r\n    var ret = [node.id];\r\n    ret = ret.concat(node.params);\r\n    ret = _.map(ret, value);\r\n    if (node.hash)\r\n      ret.push(hash(node.hash));\r\n    return ret;\r\n  };\r\n\r\n  var template = function (nodes) {\r\n    var ret = [];\r\n\r\n    if (!nodes)\r\n      return [];\r\n\r\n    var choices = {\r\n      mustache: function (node) {\r\n        ret.push([node.escaped ? '{' : '!', invocation(node)]);\r\n      },\r\n      partial: function (node) {\r\n        var id = identifier(node.id);\r\n        if (id.length !== 2 || id[0] !== 0)\r\n          // XXX actually should just get the literal string the\r\n          // entered, and avoid identifier parsing\r\n          throw new Error(\"Template names shouldn't contain '.' or '/'\");\r\n        var x = ['>', id[1]];\r\n        if (node.context)\r\n          x = ['#', [[0, 'with'], identifier(node.context)], [x]];\r\n        ret.push(x);\r\n      },\r\n      block: function (node) {\r\n        var x = ['#', invocation(node.mustache),\r\n                 template(node.program.statements)];\r\n        if (node.program.inverse)\r\n          x.push(template(node.program.inverse.statements));\r\n        ret.push(x);\r\n      },\r\n      inverse: function (node) {\r\n        ret.push(['#', invocation(node.mustache),\r\n                  node.program.inverse &&\r\n                  template(node.program.inverse.statements) || [],\r\n                  template(node.program.statements)]);\r\n      },\r\n      content: function (node) {ret.push(node.string);},\r\n      comment: function (node) {}\r\n    };\r\n\r\n    _.each(nodes, function (node) {\r\n      if (!(node.type in choices))\r\n        throw new Error(\"got ast node \" + node.type + \" in template\");\r\n      choices[node.type](node);\r\n    });\r\n\r\n    return ret;\r\n  };\r\n\r\n  if (ast.type !== \"program\")\r\n    throw new Error(\"got ast node \" + node.type + \" at toplevel\");\r\n  return template(ast.statements);\r\n};\r\n\r\nvar makeHandlebarsExceptionsVisible = function () {\r\n  hbars.Exception = function(message) {\r\n    this.message = message;\r\n    // In Node, if we don't do this we don't see the message displayed\r\n    // nor the right stack trace.\r\n    Error.captureStackTrace(this, arguments.callee);\r\n  };\r\n  hbars.Exception.prototype = new Error();\r\n  hbars.Exception.prototype.name = 'Handlebars.Exception';\r\n};\r\n"]}